<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 7 Applications | Token Economy: How the Web3 reinvents the Internet</title>
  <meta name="description" content="Chapter 7 Applications | Token Economy: How the Web3 reinvents the Internet" />
  <meta name="generator" content="bookdown 0.38 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 7 Applications | Token Economy: How the Web3 reinvents the Internet" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="Chapter 7 Applications | Token Economy: How the Web3 reinvents the Internet" />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 7 Applications | Token Economy: How the Web3 reinvents the Internet" />
  
  <meta name="twitter:description" content="Chapter 7 Applications | Token Economy: How the Web3 reinvents the Internet" />
  

<meta name="author" content="米霖 译" />


<meta name="date" content="2024-10-02" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="solidity-example.html"/>
<link rel="next" href="hacks-evm-test-and-defi.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>



<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Token Economy: How the Web3 reinvents the Internet</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> url: your book url like https://bookdown.org/yihui/bookdown</a>
<ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#有状态网络"><i class="fa fa-check"></i><b>1.1</b> 1. 有状态网络</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="index.html"><a href="index.html#区块链-一种有状态的协议"><i class="fa fa-check"></i><b>1.1.1</b> 区块链: 一种有状态的协议</a></li>
<li class="chapter" data-level="1.1.2" data-path="index.html"><a href="index.html#其他web3-协议"><i class="fa fa-check"></i><b>1.1.2</b> 其他Web3 协议</a></li>
<li class="chapter" data-level="1.1.3" data-path="index.html"><a href="index.html#web3-中的去中心化应用"><i class="fa fa-check"></i><b>1.1.3</b> Web3 中的去中心化应用</a></li>
<li class="chapter" data-level="1.1.4" data-path="index.html"><a href="index.html#章节概括"><i class="fa fa-check"></i><b>1.1.4</b> 章节概括</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#跟踪代币比特币区块链及其他分布式账本"><i class="fa fa-check"></i><b>1.2</b> 2. 跟踪代币：比特币、区块链及其他分布式账本</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="index.html"><a href="index.html#加密经济学共识与工作量证明"><i class="fa fa-check"></i><b>1.2.1</b> 加密经济学、共识与工作量证明</a></li>
<li class="chapter" data-level="1.2.2" data-path="index.html"><a href="index.html#网络节点"><i class="fa fa-check"></i><b>1.2.2</b> 网络节点</a></li>
<li class="chapter" data-level="1.2.3" data-path="index.html"><a href="index.html#网络攻击"><i class="fa fa-check"></i><b>1.2.3</b> 网络攻击</a></li>
<li class="chapter" data-level="1.2.4" data-path="index.html"><a href="index.html#协议分叉与网络分裂"><i class="fa fa-check"></i><b>1.2.4</b> 协议分叉与网络分裂</a></li>
<li class="chapter" data-level="1.2.5" data-path="index.html"><a href="index.html#替代分布式账本系统"><i class="fa fa-check"></i><b>1.2.5</b> 替代分布式账本系统</a></li>
<li class="chapter" data-level="1.2.6" data-path="index.html"><a href="index.html#替代的共识机制"><i class="fa fa-check"></i><b>1.2.6</b> 替代的共识机制</a></li>
<li class="chapter" data-level="1.2.7" data-path="index.html"><a href="index.html#是否需要代币"><i class="fa fa-check"></i><b>1.2.7</b> 是否需要代币？</a></li>
<li class="chapter" data-level="1.2.8" data-path="index.html"><a href="index.html#使用案例与应用"><i class="fa fa-check"></i><b>1.2.8</b> 使用案例与应用</a></li>
<li class="chapter" data-level="1.2.9" data-path="index.html"><a href="index.html#章节总结"><i class="fa fa-check"></i><b>1.2.9</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#代币安全-密码学"><i class="fa fa-check"></i><b>1.3</b> 3. 代币安全 ： 密码学</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="index.html"><a href="index.html#公钥密码学"><i class="fa fa-check"></i><b>1.3.1</b> 公钥密码学</a></li>
<li class="chapter" data-level="1.3.2" data-path="index.html"><a href="index.html#安全算法"><i class="fa fa-check"></i><b>1.3.2</b> 安全算法</a></li>
<li class="chapter" data-level="1.3.3" data-path="index.html"><a href="index.html#哈希"><i class="fa fa-check"></i><b>1.3.3</b> 哈希</a></li>
<li class="chapter" data-level="1.3.4" data-path="index.html"><a href="index.html#钱包与数字签名"><i class="fa fa-check"></i><b>1.3.4</b> 钱包与数字签名</a></li>
<li class="chapter" data-level="1.3.5" data-path="index.html"><a href="index.html#钱包类型与密钥管理"><i class="fa fa-check"></i><b>1.3.5</b> 钱包类型与密钥管理</a></li>
<li class="chapter" data-level="1.3.6" data-path="index.html"><a href="index.html#发送代币"><i class="fa fa-check"></i><b>1.3.6</b> 发送代币</a></li>
<li class="chapter" data-level="1.3.7" data-path="index.html"><a href="index.html#章节总结-1"><i class="fa fa-check"></i><b>1.3.7</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#谁控制着代币以用户为中心的身份"><i class="fa fa-check"></i><b>1.4</b> 4. 谁控制着代币?以用户为中心的身份</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="index.html"><a href="index.html#disclaimer"><i class="fa fa-check"></i><b>1.4.1</b> Disclaimer</a></li>
<li class="chapter" data-level="1.4.2" data-path="index.html"><a href="index.html#身份管理"><i class="fa fa-check"></i><b>1.4.2</b> 身份管理</a></li>
<li class="chapter" data-level="1.4.3" data-path="index.html"><a href="index.html#标识符"><i class="fa fa-check"></i><b>1.4.3</b> 标识符</a></li>
<li class="chapter" data-level="1.4.4" data-path="index.html"><a href="index.html#认证"><i class="fa fa-check"></i><b>1.4.4</b> 认证</a></li>
<li class="chapter" data-level="1.4.5" data-path="index.html"><a href="index.html#声明与凭证"><i class="fa fa-check"></i><b>1.4.5</b> 声明与凭证</a></li>
<li class="chapter" data-level="1.4.6" data-path="index.html"><a href="index.html#server-centric-identities"><i class="fa fa-check"></i><b>1.4.6</b> Server-Centric Identities</a></li>
<li class="chapter" data-level="1.4.7" data-path="index.html"><a href="index.html#history-of-digital-identity-management"><i class="fa fa-check"></i><b>1.4.7</b> History of Digital Identity Management</a></li>
<li class="chapter" data-level="1.4.8" data-path="index.html"><a href="index.html#user-centric-identities-using-dids"><i class="fa fa-check"></i><b>1.4.8</b> User-Centric Identities using DIDs</a></li>
<li class="chapter" data-level="1.4.9" data-path="index.html"><a href="index.html#outlook"><i class="fa fa-check"></i><b>1.4.9</b> Outlook</a></li>
<li class="chapter" data-level="1.4.10" data-path="index.html"><a href="index.html#chapter-summary"><i class="fa fa-check"></i><b>1.4.10</b> Chapter Summary</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="web3-应用.html"><a href="web3-应用.html"><i class="fa fa-check"></i><b>2</b> Web3 应用</a>
<ul>
<li class="chapter" data-level="2.1" data-path="web3-应用.html"><a href="web3-应用.html#智能合约"><i class="fa fa-check"></i><b>2.1</b> 智能合约</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="web3-应用.html"><a href="web3-应用.html#自我执行的协议"><i class="fa fa-check"></i><b>2.1.1</b> 自我执行的协议</a></li>
<li class="chapter" data-level="2.1.2" data-path="web3-应用.html"><a href="web3-应用.html#智能合约的调用与外部数据"><i class="fa fa-check"></i><b>2.1.2</b> 智能合约的调用与外部数据</a></li>
<li class="chapter" data-level="2.1.3" data-path="web3-应用.html"><a href="web3-应用.html#行业应用案例"><i class="fa fa-check"></i><b>2.1.3</b> 行业应用案例</a></li>
<li class="chapter" data-level="2.1.4" data-path="web3-应用.html"><a href="web3-应用.html#预言机"><i class="fa fa-check"></i><b>2.1.4</b> 预言机</a></li>
<li class="chapter" data-level="2.1.5" data-path="web3-应用.html"><a href="web3-应用.html#二手车购买案例"><i class="fa fa-check"></i><b>2.1.5</b> 二手车购买案例</a></li>
<li class="chapter" data-level="2.1.6" data-path="web3-应用.html"><a href="web3-应用.html#智能合约的历史"><i class="fa fa-check"></i><b>2.1.6</b> 智能合约的历史</a></li>
<li class="chapter" data-level="2.1.7" data-path="web3-应用.html"><a href="web3-应用.html#章节总结-2"><i class="fa fa-check"></i><b>2.1.7</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="web3-应用.html"><a href="web3-应用.html#web3-网络与其他-dao-的制度经济学"><i class="fa fa-check"></i><b>2.2</b> Web3 网络与其他 DAO 的制度经济学</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="web3-应用.html"><a href="web3-应用.html#daos-与传统组织"><i class="fa fa-check"></i><b>2.2.1</b> DAOs 与传统组织</a></li>
<li class="chapter" data-level="2.2.2" data-path="web3-应用.html"><a href="web3-应用.html#公司演变与企业理论"><i class="fa fa-check"></i><b>2.2.2</b> 公司演变与“企业理论”</a></li>
<li class="chapter" data-level="2.2.3" data-path="web3-应用.html"><a href="web3-应用.html#国家治理与代议制民主"><i class="fa fa-check"></i><b>2.2.3</b> 国家治理与代议制民主</a></li>
<li class="chapter" data-level="2.2.4" data-path="web3-应用.html"><a href="web3-应用.html#去中心化自治组织"><i class="fa fa-check"></i><b>2.2.4</b> 去中心化自治组织</a></li>
<li class="chapter" data-level="2.2.5" data-path="web3-应用.html"><a href="web3-应用.html#web3-网络与基于智能合约的-dao"><i class="fa fa-check"></i><b>2.2.5</b> Web3 网络与基于智能合约的 DAO</a></li>
<li class="chapter" data-level="2.2.6" data-path="web3-应用.html"><a href="web3-应用.html#dao-的制度经济学"><i class="fa fa-check"></i><b>2.2.6</b> DAO 的制度经济学</a></li>
<li class="chapter" data-level="2.2.7" data-path="web3-应用.html"><a href="web3-应用.html#dao-的货币与财政政策"><i class="fa fa-check"></i><b>2.2.7</b> DAO 的货币与财政政策</a></li>
<li class="chapter" data-level="2.2.8" data-path="web3-应用.html"><a href="web3-应用.html#章节总结-3"><i class="fa fa-check"></i><b>2.2.8</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="web3-应用.html"><a href="web3-应用.html#web3-网络与其他-daos-的治理"><i class="fa fa-check"></i><b>2.3</b> Web3 网络与其他 DAOs 的治理</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="web3-应用.html"><a href="web3-应用.html#web3-网络治理的挑战"><i class="fa fa-check"></i><b>2.3.1</b> Web3 网络治理的挑战</a></li>
<li class="chapter" data-level="2.3.2" data-path="web3-应用.html"><a href="web3-应用.html#网络中的制衡机制"><i class="fa fa-check"></i><b>2.3.2</b> 网络中的制衡机制</a></li>
<li class="chapter" data-level="2.3.3" data-path="web3-应用.html"><a href="web3-应用.html#链外治理与链上治理"><i class="fa fa-check"></i><b>2.3.3</b> 链外治理与链上治理</a></li>
<li class="chapter" data-level="2.3.4" data-path="web3-应用.html"><a href="web3-应用.html#去中心化神话与无信任网络"><i class="fa fa-check"></i><b>2.3.4</b> 去中心化神话与无信任网络</a></li>
<li class="chapter" data-level="2.3.5" data-path="web3-应用.html"><a href="web3-应用.html#章节总结-4"><i class="fa fa-check"></i><b>2.3.5</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="web3-应用.html"><a href="web3-应用.html#代币token"><i class="fa fa-check"></i><b>2.4</b> 代币（Token）</a>
<ul>
<li class="chapter" data-level="2.4.1" data-path="web3-应用.html"><a href="web3-应用.html#代币的历史"><i class="fa fa-check"></i><b>2.4.1</b> 代币的历史</a></li>
<li class="chapter" data-level="2.4.2" data-path="web3-应用.html"><a href="web3-应用.html#加密代币"><i class="fa fa-check"></i><b>2.4.2</b> 加密代币</a></li>
<li class="chapter" data-level="2.4.3" data-path="web3-应用.html"><a href="web3-应用.html#代币的属性"><i class="fa fa-check"></i><b>2.4.3</b> 代币的属性</a></li>
<li class="chapter" data-level="2.4.4" data-path="web3-应用.html"><a href="web3-应用.html#非同质化代币-nft"><i class="fa fa-check"></i><b>2.4.4</b> 非同质化代币 (NFT)</a></li>
<li class="chapter" data-level="2.4.5" data-path="web3-应用.html"><a href="web3-应用.html#章节总结-5"><i class="fa fa-check"></i><b>2.4.5</b> 章节总结</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html"><i class="fa fa-check"></i><b>3</b> 代币经济和去中心化金融</a>
<ul>
<li class="chapter" data-level="3.1" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#货币与去中心化金融defi的未来"><i class="fa fa-check"></i><b>3.1</b> 货币与去中心化金融（DeFi）的未来</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#货币的属性"><i class="fa fa-check"></i><b>3.1.1</b> 货币的属性</a></li>
<li class="chapter" data-level="3.1.2" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#货币的类型"><i class="fa fa-check"></i><b>3.1.2</b> 货币的类型</a></li>
<li class="chapter" data-level="3.1.3" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#货币还是非货币"><i class="fa fa-check"></i><b>3.1.3</b> 货币还是非货币？</a></li>
<li class="chapter" data-level="3.1.4" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#去中心化金融defi迈向数字货币经济"><i class="fa fa-check"></i><b>3.1.4</b> 去中心化金融（DeFi）：迈向数字货币经济</a></li>
<li class="chapter" data-level="3.1.5" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#章节总结-6"><i class="fa fa-check"></i><b>3.1.5</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#稳定代币-stable-tokens"><i class="fa fa-check"></i><b>3.2</b> 稳定代币 Stable Tokens</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#资产担保的稳定代币"><i class="fa fa-check"></i><b>3.2.1</b> 资产担保的稳定代币</a></li>
<li class="chapter" data-level="3.2.2" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#加密担保的稳定代币"><i class="fa fa-check"></i><b>3.2.2</b> 加密担保的稳定代币</a></li>
<li class="chapter" data-level="3.2.3" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#中央银行数字货币"><i class="fa fa-check"></i><b>3.2.3</b> 中央银行数字货币</a></li>
<li class="chapter" data-level="3.2.4" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#算法稳定代币"><i class="fa fa-check"></i><b>3.2.4</b> 算法稳定代币</a></li>
<li class="chapter" data-level="3.2.5" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#挑战与展望"><i class="fa fa-check"></i><b>3.2.5</b> 挑战与展望</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#隐私代币"><i class="fa fa-check"></i><b>3.3</b> 隐私代币</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#区块链代币的隐私性"><i class="fa fa-check"></i><b>3.3.1</b> 区块链代币的隐私性</a></li>
<li class="chapter" data-level="3.3.2" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#隐私代币的历史"><i class="fa fa-check"></i><b>3.3.2</b> 隐私代币的历史</a></li>
<li class="chapter" data-level="3.3.3" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#完全web3隐私"><i class="fa fa-check"></i><b>3.3.3</b> 完全Web3隐私</a></li>
<li class="chapter" data-level="3.3.4" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#隐私的法律与政治方面"><i class="fa fa-check"></i><b>3.3.4</b> 隐私的法律与政治方面</a></li>
<li class="chapter" data-level="3.3.5" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#章节总结-7"><i class="fa fa-check"></i><b>3.3.5</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#交易代币原子交换与去中心化交易所"><i class="fa fa-check"></i><b>3.4</b> 交易代币、原子交换与去中心化交易所</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#集中式交易所的挑战"><i class="fa fa-check"></i><b>3.4.1</b> 集中式交易所的挑战</a></li>
<li class="chapter" data-level="3.4.2" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#原子交换-atomic-swaps"><i class="fa fa-check"></i><b>3.4.2</b> 原子交换 Atomic Swaps</a></li>
<li class="chapter" data-level="3.4.3" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#去中心化交易所"><i class="fa fa-check"></i><b>3.4.3</b> 去中心化交易所</a></li>
<li class="chapter" data-level="3.4.4" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#章节总结-8"><i class="fa fa-check"></i><b>3.4.4</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#借贷代币与去中心化信用系统"><i class="fa fa-check"></i><b>3.5</b> 借贷代币与去中心化信用系统</a>
<ul>
<li class="chapter" data-level="3.5.1" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#p2p-借贷"><i class="fa fa-check"></i><b>3.5.1</b> P2P 借贷</a></li>
<li class="chapter" data-level="3.5.2" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#p2p-借款"><i class="fa fa-check"></i><b>3.5.2</b> P2P 借款</a></li>
<li class="chapter" data-level="3.5.3" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#闪电贷款"><i class="fa fa-check"></i><b>3.5.3</b> 闪电贷款</a></li>
<li class="chapter" data-level="3.5.4" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#p2p-借贷协议"><i class="fa fa-check"></i><b>3.5.4</b> P2P 借贷协议</a></li>
<li class="chapter" data-level="3.5.5" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#闪电攻击"><i class="fa fa-check"></i><b>3.5.5</b> 闪电攻击</a></li>
<li class="chapter" data-level="3.5.6" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#章节总结-9"><i class="fa fa-check"></i><b>3.5.6</b> 章节总结</a></li>
<li class="chapter" data-level="3.5.7" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#闪电贷款-1"><i class="fa fa-check"></i><b>3.5.7</b> 闪电贷款</a></li>
<li class="chapter" data-level="3.5.8" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#闪电攻击-1"><i class="fa fa-check"></i><b>3.5.8</b> 闪电攻击</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#token-sales-icos-itos-ieos-stos"><i class="fa fa-check"></i><b>3.6</b> Token Sales: ICOs, ITOs, IEOs, STOs</a>
<ul>
<li class="chapter" data-level="3.6.1" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#history-of-token-sales"><i class="fa fa-check"></i><b>3.6.1</b> History of Token Sales</a></li>
<li class="chapter" data-level="3.6.2" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#types-of-token-sales"><i class="fa fa-check"></i><b>3.6.2</b> Types of Token Sales</a></li>
<li class="chapter" data-level="3.6.3" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#challenges-of-token-sales"><i class="fa fa-check"></i><b>3.6.3</b> Challenges of Token Sales</a></li>
<li class="chapter" data-level="3.6.4" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#initial-exchange-offerings-ieos-首次公开发行"><i class="fa fa-check"></i><b>3.6.4</b> Initial Exchange Offerings (IEOs) 首次公开发行</a></li>
<li class="chapter" data-level="3.6.5" data-path="代币经济和去中心化金融.html"><a href="代币经济和去中心化金融.html#章节总结-10"><i class="fa fa-check"></i><b>3.6.5</b> 章节总结</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html"><i class="fa fa-check"></i><b>4</b> Token Use Cases 代币用例</a>
<ul>
<li class="chapter" data-level="4.1" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#资产代币与分权所有权"><i class="fa fa-check"></i><b>4.1</b> 资产代币与分权所有权</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#用例-1证券代币"><i class="fa fa-check"></i><b>4.1.1</b> 用例 1：证券代币</a></li>
<li class="chapter" data-level="4.1.2" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#用例-2房地产代币化"><i class="fa fa-check"></i><b>4.1.2</b> 用例 2：房地产代币化</a></li>
<li class="chapter" data-level="4.1.3" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#用例-3艺术代币化"><i class="fa fa-check"></i><b>4.1.3</b> 用例 3：艺术代币化</a></li>
<li class="chapter" data-level="4.1.4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#用例-4集体部分所有权"><i class="fa fa-check"></i><b>4.1.4</b> 用例 4：集体部分所有权</a></li>
<li class="chapter" data-level="4.1.5" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#章节总结-11"><i class="fa fa-check"></i><b>4.1.5</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#目的驱动代币"><i class="fa fa-check"></i><b>4.2</b> 目的驱动代币</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#激励网络状态共识"><i class="fa fa-check"></i><b>4.2.1</b> 激励网络状态共识</a></li>
<li class="chapter" data-level="4.2.2" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#激励社交媒体贡献"><i class="fa fa-check"></i><b>4.2.2</b> 激励社交媒体贡献</a></li>
<li class="chapter" data-level="4.2.3" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#激励清单贡献"><i class="fa fa-check"></i><b>4.2.3</b> 激励清单贡献</a></li>
<li class="chapter" data-level="4.2.4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#激励减少二氧化碳排放"><i class="fa fa-check"></i><b>4.2.4</b> 激励减少二氧化碳排放</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#公共物品与公地悲剧"><i class="fa fa-check"></i><b>4.3</b> 公共物品与公地悲剧</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#正外部性与负外部性"><i class="fa fa-check"></i><b>4.3.1</b> 正外部性与负外部性</a></li>
<li class="chapter" data-level="4.3.2" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#行为经济学与引导"><i class="fa fa-check"></i><b>4.3.2</b> 行为经济学与引导</a></li>
<li class="chapter" data-level="4.3.3" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#认知心理学与行为分析"><i class="fa fa-check"></i><b>4.3.3</b> 认知心理学与行为分析</a></li>
<li class="chapter" data-level="4.3.4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#行为金融与行为博弈理论"><i class="fa fa-check"></i><b>4.3.4</b> 行为金融与行为博弈理论</a></li>
<li class="chapter" data-level="4.3.5" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#机制设计与代币工程"><i class="fa fa-check"></i><b>4.3.5</b> 机制设计与代币工程</a></li>
<li class="chapter" data-level="4.3.6" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#章节总结-12"><i class="fa fa-check"></i><b>4.3.6</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#steemithive-和-reddit代币化社交网络"><i class="fa fa-check"></i><b>4.4</b> Steemit、Hive 和 Reddit：代币化社交网络</a>
<ul>
<li class="chapter" data-level="4.4.1" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#当今社交媒体的问题"><i class="fa fa-check"></i><b>4.4.1</b> 当今社交媒体的问题</a></li>
<li class="chapter" data-level="4.4.2" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#steemit-的代币经济学"><i class="fa fa-check"></i><b>4.4.2</b> Steemit 的代币经济学</a></li>
<li class="chapter" data-level="4.4.3" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#steemit-的批评"><i class="fa fa-check"></i><b>4.4.3</b> Steemit 的批评</a></li>
<li class="chapter" data-level="4.4.4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#steemit-硬分叉hive-网络"><i class="fa fa-check"></i><b>4.4.4</b> Steemit 硬分叉：Hive 网络</a></li>
<li class="chapter" data-level="4.4.5" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#reddit将-web2-平台代币化"><i class="fa fa-check"></i><b>4.4.5</b> Reddit：将 Web2 平台代币化</a></li>
<li class="chapter" data-level="4.4.6" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#章节总结-13"><i class="fa fa-check"></i><b>4.4.6</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#基本注意力代币广告的重新定义"><i class="fa fa-check"></i><b>4.5</b> 基本注意力代币：广告的重新定义</a>
<ul>
<li class="chapter" data-level="4.5.1" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#注意力经济数据市场与隐私"><i class="fa fa-check"></i><b>4.5.1</b> 注意力经济、数据市场与隐私</a></li>
<li class="chapter" data-level="4.5.2" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#基本注意力代币bat"><i class="fa fa-check"></i><b>4.5.2</b> 基本注意力代币（BAT）</a></li>
<li class="chapter" data-level="4.5.3" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#展望与挑战"><i class="fa fa-check"></i><b>4.5.3</b> 展望与挑战</a></li>
<li class="chapter" data-level="4.5.4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#章节总结-14"><i class="fa fa-check"></i><b>4.5.4</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#代币策划注册新的搜索方式"><i class="fa fa-check"></i><b>4.6</b> 代币策划注册：新的搜索方式？</a>
<ul>
<li class="chapter" data-level="4.6.1" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#代币策划注册tcrs如何运作"><i class="fa fa-check"></i><b>4.6.1</b> 代币策划注册（TCRs）如何运作</a></li>
<li class="chapter" data-level="4.6.2" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#攻击向量"><i class="fa fa-check"></i><b>4.6.2</b> 攻击向量</a></li>
<li class="chapter" data-level="4.6.3" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#tcrs的批评"><i class="fa fa-check"></i><b>4.6.3</b> TCRs的批评</a></li>
<li class="chapter" data-level="4.6.4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#tcr的其他类型"><i class="fa fa-check"></i><b>4.6.4</b> TCR的其他类型</a></li>
<li class="chapter" data-level="4.6.5" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#章节总结-15"><i class="fa fa-check"></i><b>4.6.5</b> 章节总结</a></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#如何设计代币系统"><i class="fa fa-check"></i><b>4.7</b> 如何设计代币系统</a>
<ul>
<li class="chapter" data-level="4.7.1" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#技术工程"><i class="fa fa-check"></i><b>4.7.1</b> 技术工程</a></li>
<li class="chapter" data-level="4.7.2" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#法律工程"><i class="fa fa-check"></i><b>4.7.2</b> 法律工程</a></li>
<li class="chapter" data-level="4.7.3" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#经济工程"><i class="fa fa-check"></i><b>4.7.3</b> 经济工程</a></li>
<li class="chapter" data-level="4.7.4" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#伦理工程"><i class="fa fa-check"></i><b>4.7.4</b> 伦理工程</a></li>
<li class="chapter" data-level="4.7.5" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#多学科团队的重要性"><i class="fa fa-check"></i><b>4.7.5</b> 多学科团队的重要性</a></li>
<li class="chapter" data-level="4.7.6" data-path="token-use-cases-代币用例.html"><a href="token-use-cases-代币用例.html#章节总结-16"><i class="fa fa-check"></i><b>4.7.6</b> 章节总结</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="补充内容.html"><a href="补充内容.html"><i class="fa fa-check"></i><b>5</b> 补充内容</a>
<ul>
<li class="chapter" data-level="5.1" data-path="补充内容.html"><a href="补充内容.html#比特币与web3的起源"><i class="fa fa-check"></i><b>5.1</b> 比特币与Web3的起源</a></li>
<li class="chapter" data-level="5.2" data-path="补充内容.html"><a href="补充内容.html#区块链可扩展性解决方案"><i class="fa fa-check"></i><b>5.2</b> 区块链可扩展性解决方案</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="补充内容.html"><a href="补充内容.html#状态通道"><i class="fa fa-check"></i><b>5.2.1</b> 状态通道</a></li>
<li class="chapter" data-level="5.2.2" data-path="补充内容.html"><a href="补充内容.html#侧链"><i class="fa fa-check"></i><b>5.2.2</b> 侧链</a></li>
<li class="chapter" data-level="5.2.3" data-path="补充内容.html"><a href="补充内容.html#区块链互操作性"><i class="fa fa-check"></i><b>5.2.3</b> 区块链互操作性</a></li>
<li class="chapter" data-level="5.2.4" data-path="补充内容.html"><a href="补充内容.html#分片"><i class="fa fa-check"></i><b>5.2.4</b> 分片</a></li>
<li class="chapter" data-level="5.2.5" data-path="补充内容.html"><a href="补充内容.html#替代加密算法"><i class="fa fa-check"></i><b>5.2.5</b> 替代加密算法</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="补充内容.html"><a href="补充内容.html#libra与celo"><i class="fa fa-check"></i><b>5.3</b> Libra与Celo</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="solidity-example.html"><a href="solidity-example.html"><i class="fa fa-check"></i><b>6</b> Solidity Example</a>
<ul>
<li class="chapter" data-level="6.1" data-path="solidity-example.html"><a href="solidity-example.html#hellow-world"><i class="fa fa-check"></i><b>6.1</b> 1. Hellow world</a></li>
<li class="chapter" data-level="6.2" data-path="solidity-example.html"><a href="solidity-example.html#简单合约"><i class="fa fa-check"></i><b>6.2</b> 2. 简单合约</a></li>
<li class="chapter" data-level="6.3" data-path="solidity-example.html"><a href="solidity-example.html#数据类型"><i class="fa fa-check"></i><b>6.3</b> 3. 数据类型</a></li>
<li class="chapter" data-level="6.4" data-path="solidity-example.html"><a href="solidity-example.html#变量"><i class="fa fa-check"></i><b>6.4</b> 4. 变量</a></li>
<li class="chapter" data-level="6.5" data-path="solidity-example.html"><a href="solidity-example.html#常量"><i class="fa fa-check"></i><b>6.5</b> 5. 常量</a></li>
<li class="chapter" data-level="6.6" data-path="solidity-example.html"><a href="solidity-example.html#不可变-immutable"><i class="fa fa-check"></i><b>6.6</b> 6. 不可变 Immutable</a></li>
<li class="chapter" data-level="6.7" data-path="solidity-example.html"><a href="solidity-example.html#状态变量的读写"><i class="fa fa-check"></i><b>6.7</b> 7. 状态变量的读写</a></li>
<li class="chapter" data-level="6.8" data-path="solidity-example.html"><a href="solidity-example.html#以太-ether-和-wei"><i class="fa fa-check"></i><b>6.8</b> 8. 以太 Ether 和 Wei</a></li>
<li class="chapter" data-level="6.9" data-path="solidity-example.html"><a href="solidity-example.html#gas"><i class="fa fa-check"></i><b>6.9</b> 9. gas</a></li>
<li class="chapter" data-level="6.10" data-path="solidity-example.html"><a href="solidity-example.html#条件判断"><i class="fa fa-check"></i><b>6.10</b> 10. 条件判断</a></li>
<li class="chapter" data-level="6.11" data-path="solidity-example.html"><a href="solidity-example.html#循环"><i class="fa fa-check"></i><b>6.11</b> 11. 循环</a></li>
<li class="chapter" data-level="6.12" data-path="solidity-example.html"><a href="solidity-example.html#mapping"><i class="fa fa-check"></i><b>6.12</b> 12. mapping</a></li>
<li class="chapter" data-level="6.13" data-path="solidity-example.html"><a href="solidity-example.html#array"><i class="fa fa-check"></i><b>6.13</b> 13. array</a></li>
<li class="chapter" data-level="6.14" data-path="solidity-example.html"><a href="solidity-example.html#枚举"><i class="fa fa-check"></i><b>6.14</b> 14. 枚举</a></li>
<li class="chapter" data-level="6.15" data-path="solidity-example.html"><a href="solidity-example.html#用户定义类型"><i class="fa fa-check"></i><b>6.15</b> 15. 用户定义类型</a></li>
<li class="chapter" data-level="6.16" data-path="solidity-example.html"><a href="solidity-example.html#结构体"><i class="fa fa-check"></i><b>6.16</b> 16. 结构体</a></li>
<li class="chapter" data-level="6.17" data-path="solidity-example.html"><a href="solidity-example.html#数据位置---storage-memorycalldata"><i class="fa fa-check"></i><b>6.17</b> 17. 数据位置 - storage ， memory，calldata</a></li>
<li class="chapter" data-level="6.18" data-path="solidity-example.html"><a href="solidity-example.html#暂时存储"><i class="fa fa-check"></i><b>6.18</b> 18. 暂时存储</a></li>
<li class="chapter" data-level="6.19" data-path="solidity-example.html"><a href="solidity-example.html#函数"><i class="fa fa-check"></i><b>6.19</b> 19. 函数</a></li>
<li class="chapter" data-level="6.20" data-path="solidity-example.html"><a href="solidity-example.html#view-和-pure-函数"><i class="fa fa-check"></i><b>6.20</b> 20. view 和 pure 函数</a></li>
<li class="chapter" data-level="6.21" data-path="solidity-example.html"><a href="solidity-example.html#错误"><i class="fa fa-check"></i><b>6.21</b> 21. 错误</a></li>
<li class="chapter" data-level="6.22" data-path="solidity-example.html"><a href="solidity-example.html#函数修饰符"><i class="fa fa-check"></i><b>6.22</b> 22. 函数修饰符</a></li>
<li class="chapter" data-level="6.23" data-path="solidity-example.html"><a href="solidity-example.html#event-事件"><i class="fa fa-check"></i><b>6.23</b> 23 event 事件</a></li>
<li class="chapter" data-level="6.24" data-path="solidity-example.html"><a href="solidity-example.html#事件高级主题"><i class="fa fa-check"></i><b>6.24</b> 24. 事件高级主题</a></li>
<li class="chapter" data-level="6.25" data-path="solidity-example.html"><a href="solidity-example.html#构造函数"><i class="fa fa-check"></i><b>6.25</b> 25. 构造函数</a></li>
<li class="chapter" data-level="6.26" data-path="solidity-example.html"><a href="solidity-example.html#继承"><i class="fa fa-check"></i><b>6.26</b> 26 继承</a></li>
<li class="chapter" data-level="6.27" data-path="solidity-example.html"><a href="solidity-example.html#隐藏继承状态变量"><i class="fa fa-check"></i><b>6.27</b> 27 隐藏继承状态变量</a></li>
<li class="chapter" data-level="6.28" data-path="solidity-example.html"><a href="solidity-example.html#调用父合约"><i class="fa fa-check"></i><b>6.28</b> 28.调用父合约</a></li>
<li class="chapter" data-level="6.29" data-path="solidity-example.html"><a href="solidity-example.html#visibility-可见度"><i class="fa fa-check"></i><b>6.29</b> 29. visibility 可见度</a></li>
<li class="chapter" data-level="6.30" data-path="solidity-example.html"><a href="solidity-example.html#interface-接口"><i class="fa fa-check"></i><b>6.30</b> 30 interface 接口</a></li>
<li class="chapter" data-level="6.31" data-path="solidity-example.html"><a href="solidity-example.html#payable"><i class="fa fa-check"></i><b>6.31</b> 31 payable</a></li>
<li class="chapter" data-level="6.32" data-path="solidity-example.html"><a href="solidity-example.html#发送以太币"><i class="fa fa-check"></i><b>6.32</b> 32 发送以太币</a>
<ul>
<li class="chapter" data-level="6.32.1" data-path="solidity-example.html"><a href="solidity-example.html#发送以太币transfersendcall"><i class="fa fa-check"></i><b>6.32.1</b> 发送以太币（transfer、send、call）</a></li>
</ul></li>
<li class="chapter" data-level="6.33" data-path="solidity-example.html"><a href="solidity-example.html#fallback"><i class="fa fa-check"></i><b>6.33</b> 33 Fallback</a></li>
<li class="chapter" data-level="6.34" data-path="solidity-example.html"><a href="solidity-example.html#call"><i class="fa fa-check"></i><b>6.34</b> 34 call</a>
<ul>
<li class="chapter" data-level="6.34.1" data-path="solidity-example.html"><a href="solidity-example.html#call-函数"><i class="fa fa-check"></i><b>6.34.1</b> call 函数</a></li>
</ul></li>
<li class="chapter" data-level="6.35" data-path="solidity-example.html"><a href="solidity-example.html#delegatecall"><i class="fa fa-check"></i><b>6.35</b> 35 Delegatecall</a>
<ul>
<li class="chapter" data-level="6.35.1" data-path="solidity-example.html"><a href="solidity-example.html#delegatecall-1"><i class="fa fa-check"></i><b>6.35.1</b> delegatecall</a></li>
</ul></li>
<li class="chapter" data-level="6.36" data-path="solidity-example.html"><a href="solidity-example.html#function-selector-函数选择器"><i class="fa fa-check"></i><b>6.36</b> 36 Function selector 函数选择器</a></li>
<li class="chapter" data-level="6.37" data-path="solidity-example.html"><a href="solidity-example.html#合约间调用"><i class="fa fa-check"></i><b>6.37</b> 37 合约间调用</a></li>
<li class="chapter" data-level="6.38" data-path="solidity-example.html"><a href="solidity-example.html#通过合约创建其他合约"><i class="fa fa-check"></i><b>6.38</b> 38 通过合约创建其他合约</a></li>
<li class="chapter" data-level="6.39" data-path="solidity-example.html"><a href="solidity-example.html#trycatch"><i class="fa fa-check"></i><b>6.39</b> 39 try/catch</a></li>
<li class="chapter" data-level="6.40" data-path="solidity-example.html"><a href="solidity-example.html#import-导入"><i class="fa fa-check"></i><b>6.40</b> 40 import 导入</a>
<ul>
<li class="chapter" data-level="6.40.1" data-path="solidity-example.html"><a href="solidity-example.html#本地导入"><i class="fa fa-check"></i><b>6.40.1</b> 本地导入</a></li>
<li class="chapter" data-level="6.40.2" data-path="solidity-example.html"><a href="solidity-example.html#外部导入"><i class="fa fa-check"></i><b>6.40.2</b> 外部导入</a></li>
<li class="chapter" data-level="6.40.3" data-path="solidity-example.html"><a href="solidity-example.html#代码说明"><i class="fa fa-check"></i><b>6.40.3</b> 代码说明</a></li>
</ul></li>
<li class="chapter" data-level="6.41" data-path="solidity-example.html"><a href="solidity-example.html#library"><i class="fa fa-check"></i><b>6.41</b> 41 library</a>
<ul>
<li class="chapter" data-level="6.41.1" data-path="solidity-example.html"><a href="solidity-example.html#solidity-中的库"><i class="fa fa-check"></i><b>6.41.1</b> Solidity 中的库</a></li>
<li class="chapter" data-level="6.41.2" data-path="solidity-example.html"><a href="solidity-example.html#关键点"><i class="fa fa-check"></i><b>6.41.2</b> 关键点</a></li>
</ul></li>
<li class="chapter" data-level="6.42" data-path="solidity-example.html"><a href="solidity-example.html#abi-encode"><i class="fa fa-check"></i><b>6.42</b> 42 ABI Encode</a></li>
<li class="chapter" data-level="6.43" data-path="solidity-example.html"><a href="solidity-example.html#abi-decode"><i class="fa fa-check"></i><b>6.43</b> 43 ABI Decode</a></li>
<li class="chapter" data-level="6.44" data-path="solidity-example.html"><a href="solidity-example.html#hashing-with-keccak256"><i class="fa fa-check"></i><b>6.44</b> 44 Hashing with Keccak256</a>
<ul>
<li class="chapter" data-level="6.44.1" data-path="solidity-example.html"><a href="solidity-example.html#keccak256-函数"><i class="fa fa-check"></i><b>6.44.1</b> keccak256 函数</a></li>
</ul></li>
<li class="chapter" data-level="6.45" data-path="solidity-example.html"><a href="solidity-example.html#验证签名"><i class="fa fa-check"></i><b>6.45</b> 45 验证签名</a></li>
<li class="chapter" data-level="6.46" data-path="solidity-example.html"><a href="solidity-example.html#节省-gas-的技巧"><i class="fa fa-check"></i><b>6.46</b> 46 节省 gas 的技巧</a></li>
<li class="chapter" data-level="6.47" data-path="solidity-example.html"><a href="solidity-example.html#按位运算符-bitwise-operators"><i class="fa fa-check"></i><b>6.47</b> 47 按位运算符 Bitwise Operators</a></li>
<li class="chapter" data-level="6.48" data-path="solidity-example.html"><a href="solidity-example.html#数字溢出"><i class="fa fa-check"></i><b>6.48</b> 48 数字溢出</a></li>
<li class="chapter" data-level="6.49" data-path="solidity-example.html"><a href="solidity-example.html#assembly"><i class="fa fa-check"></i><b>6.49</b> 49 Assembly</a>
<ul>
<li class="chapter" data-level="6.49.1" data-path="solidity-example.html"><a href="solidity-example.html#assembly-的特点"><i class="fa fa-check"></i><b>6.49.1</b> Assembly 的特点</a></li>
<li class="chapter" data-level="6.49.2" data-path="solidity-example.html"><a href="solidity-example.html#示例"><i class="fa fa-check"></i><b>6.49.2</b> 示例</a></li>
<li class="chapter" data-level="6.49.3" data-path="solidity-example.html"><a href="solidity-example.html#注意事项"><i class="fa fa-check"></i><b>6.49.3</b> 注意事项</a></li>
<li class="chapter" data-level="6.49.4" data-path="solidity-example.html"><a href="solidity-example.html#assembly-conditional-statements"><i class="fa fa-check"></i><b>6.49.4</b> Assembly Conditional Statements</a></li>
<li class="chapter" data-level="6.49.5" data-path="solidity-example.html"><a href="solidity-example.html#assembly-loop"><i class="fa fa-check"></i><b>6.49.5</b> Assembly Loop</a></li>
<li class="chapter" data-level="6.49.6" data-path="solidity-example.html"><a href="solidity-example.html#assembly-error"><i class="fa fa-check"></i><b>6.49.6</b> Assembly Error</a></li>
<li class="chapter" data-level="6.49.7" data-path="solidity-example.html"><a href="solidity-example.html#assembly-math"><i class="fa fa-check"></i><b>6.49.7</b> Assembly Math</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="applications.html"><a href="applications.html"><i class="fa fa-check"></i><b>7</b> Applications</a>
<ul>
<li class="chapter" data-level="7.1" data-path="applications.html"><a href="applications.html#ether-wallet"><i class="fa fa-check"></i><b>7.1</b> 1 Ether Wallet</a></li>
<li class="chapter" data-level="7.2" data-path="applications.html"><a href="applications.html#多签名钱包"><i class="fa fa-check"></i><b>7.2</b> 2 多签名钱包</a></li>
<li class="chapter" data-level="7.3" data-path="applications.html"><a href="applications.html#merkle树"><i class="fa fa-check"></i><b>7.3</b> 3 Merkle树</a></li>
<li class="chapter" data-level="7.4" data-path="applications.html"><a href="applications.html#iterable映射"><i class="fa fa-check"></i><b>7.4</b> 4 Iterable映射</a></li>
<li class="chapter" data-level="7.5" data-path="applications.html"><a href="applications.html#erc20-标准"><i class="fa fa-check"></i><b>7.5</b> 5 ERC20 标准</a>
<ul>
<li class="chapter" data-level="7.5.1" data-path="applications.html"><a href="applications.html#erc20-标准-1"><i class="fa fa-check"></i><b>7.5.1</b> ERC20 标准</a></li>
<li class="chapter" data-level="7.5.2" data-path="applications.html"><a href="applications.html#erc20-代币合约示例"><i class="fa fa-check"></i><b>7.5.2</b> ERC20 代币合约示例</a></li>
<li class="chapter" data-level="7.5.3" data-path="applications.html"><a href="applications.html#创建您自己的-erc20-代币"><i class="fa fa-check"></i><b>7.5.3</b> 创建您自己的 ERC20 代币</a></li>
<li class="chapter" data-level="7.5.4" data-path="applications.html"><a href="applications.html#代币交换合约"><i class="fa fa-check"></i><b>7.5.4</b> 代币交换合约</a></li>
</ul></li>
<li class="chapter" data-level="7.6" data-path="applications.html"><a href="applications.html#erc721"><i class="fa fa-check"></i><b>7.6</b> 6 ERC721</a>
<ul>
<li class="chapter" data-level="7.6.1" data-path="applications.html"><a href="applications.html#erc721-标准简介"><i class="fa fa-check"></i><b>7.6.1</b> ERC721 标准简介</a></li>
<li class="chapter" data-level="7.6.2" data-path="applications.html"><a href="applications.html#主要特点"><i class="fa fa-check"></i><b>7.6.2</b> 主要特点</a></li>
<li class="chapter" data-level="7.6.3" data-path="applications.html"><a href="applications.html#erc721-接口"><i class="fa fa-check"></i><b>7.6.3</b> ERC721 接口</a></li>
<li class="chapter" data-level="7.6.4" data-path="applications.html"><a href="applications.html#应用场景"><i class="fa fa-check"></i><b>7.6.4</b> 应用场景</a></li>
</ul></li>
<li class="chapter" data-level="7.7" data-path="applications.html"><a href="applications.html#erc1155"><i class="fa fa-check"></i><b>7.7</b> 7 ERC1155</a>
<ul>
<li class="chapter" data-level="7.7.1" data-path="applications.html"><a href="applications.html#主要特点-1"><i class="fa fa-check"></i><b>7.7.1</b> 主要特点</a></li>
<li class="chapter" data-level="7.7.2" data-path="applications.html"><a href="applications.html#erc1155-接口"><i class="fa fa-check"></i><b>7.7.2</b> ERC1155 接口</a></li>
<li class="chapter" data-level="7.7.3" data-path="applications.html"><a href="applications.html#应用场景-1"><i class="fa fa-check"></i><b>7.7.3</b> 应用场景</a></li>
</ul></li>
<li class="chapter" data-level="7.8" data-path="applications.html"><a href="applications.html#gasless-token-transfer"><i class="fa fa-check"></i><b>7.8</b> 8 Gasless Token Transfer</a>
<ul>
<li class="chapter" data-level="7.8.1" data-path="applications.html"><a href="applications.html#主要特点-2"><i class="fa fa-check"></i><b>7.8.1</b> 主要特点</a></li>
<li class="chapter" data-level="7.8.2" data-path="applications.html"><a href="applications.html#应用场景-2"><i class="fa fa-check"></i><b>7.8.2</b> 应用场景</a></li>
</ul></li>
<li class="chapter" data-level="7.9" data-path="applications.html"><a href="applications.html#simple-bytecode-contract"><i class="fa fa-check"></i><b>7.9</b> 9 Simple Bytecode Contract</a>
<ul>
<li class="chapter" data-level="7.9.1" data-path="applications.html"><a href="applications.html#主要特点-3"><i class="fa fa-check"></i><b>7.9.1</b> 主要特点</a></li>
<li class="chapter" data-level="7.9.2" data-path="applications.html"><a href="applications.html#应用场景-3"><i class="fa fa-check"></i><b>7.9.2</b> 应用场景</a></li>
</ul></li>
<li class="chapter" data-level="7.10" data-path="applications.html"><a href="applications.html#precompute-contract-address-with-create2"><i class="fa fa-check"></i><b>7.10</b> 10 Precompute Contract Address with Create2</a>
<ul>
<li class="chapter" data-level="7.10.1" data-path="applications.html"><a href="applications.html#主要特点-4"><i class="fa fa-check"></i><b>7.10.1</b> 主要特点</a></li>
<li class="chapter" data-level="7.10.2" data-path="applications.html"><a href="applications.html#应用场景-4"><i class="fa fa-check"></i><b>7.10.2</b> 应用场景</a></li>
</ul></li>
<li class="chapter" data-level="7.11" data-path="applications.html"><a href="applications.html#minimal-proxy-contract"><i class="fa fa-check"></i><b>7.11</b> 10 Minimal Proxy Contract</a>
<ul>
<li class="chapter" data-level="7.11.1" data-path="applications.html"><a href="applications.html#主要特点-5"><i class="fa fa-check"></i><b>7.11.1</b> 主要特点</a></li>
<li class="chapter" data-level="7.11.2" data-path="applications.html"><a href="applications.html#应用场景-5"><i class="fa fa-check"></i><b>7.11.2</b> 应用场景</a></li>
</ul></li>
<li class="chapter" data-level="7.12" data-path="applications.html"><a href="applications.html#upgradeable-proxy"><i class="fa fa-check"></i><b>7.12</b> 11 Upgradeable Proxy</a></li>
<li class="chapter" data-level="7.13" data-path="applications.html"><a href="applications.html#deploy-any-contract"><i class="fa fa-check"></i><b>7.13</b> 12 Deploy Any Contract</a></li>
<li class="chapter" data-level="7.14" data-path="applications.html"><a href="applications.html#write-to-any-slot"><i class="fa fa-check"></i><b>7.14</b> 13 Write to Any Slot</a></li>
<li class="chapter" data-level="7.15" data-path="applications.html"><a href="applications.html#单向支付渠道"><i class="fa fa-check"></i><b>7.15</b> 14 单向支付渠道</a></li>
<li class="chapter" data-level="7.16" data-path="applications.html"><a href="applications.html#bi-directional-payment-channel"><i class="fa fa-check"></i><b>7.16</b> 15 Bi-Directional Payment Channel</a></li>
<li class="chapter" data-level="7.17" data-path="applications.html"><a href="applications.html#英式拍卖"><i class="fa fa-check"></i><b>7.17</b> 16 英式拍卖</a></li>
<li class="chapter" data-level="7.18" data-path="applications.html"><a href="applications.html#荷兰式拍卖"><i class="fa fa-check"></i><b>7.18</b> 17 荷兰式拍卖</a></li>
<li class="chapter" data-level="7.19" data-path="applications.html"><a href="applications.html#众筹erc20代币"><i class="fa fa-check"></i><b>7.19</b> 18 众筹ERC20代币</a></li>
<li class="chapter" data-level="7.20" data-path="applications.html"><a href="applications.html#multi-call"><i class="fa fa-check"></i><b>7.20</b> 19 Multi Call</a></li>
<li class="chapter" data-level="7.21" data-path="applications.html"><a href="applications.html#multi-delegatecall"><i class="fa fa-check"></i><b>7.21</b> 20 Multi Delegatecall</a>
<ul>
<li class="chapter" data-level="7.21.1" data-path="applications.html"><a href="applications.html#合约解释"><i class="fa fa-check"></i><b>7.21.1</b> 合约解释</a></li>
<li class="chapter" data-level="7.21.2" data-path="applications.html"><a href="applications.html#使用场景"><i class="fa fa-check"></i><b>7.21.2</b> 使用场景</a></li>
<li class="chapter" data-level="7.21.3" data-path="applications.html"><a href="applications.html#注意事项-1"><i class="fa fa-check"></i><b>7.21.3</b> 注意事项</a></li>
</ul></li>
<li class="chapter" data-level="7.22" data-path="applications.html"><a href="applications.html#时间锁-time-lock"><i class="fa fa-check"></i><b>7.22</b> 21 时间锁 Time Lock</a>
<ul>
<li class="chapter" data-level="7.22.1" data-path="applications.html"><a href="applications.html#合约结构与功能"><i class="fa fa-check"></i><b>7.22.1</b> 合约结构与功能</a></li>
<li class="chapter" data-level="7.22.2" data-path="applications.html"><a href="applications.html#主要功能"><i class="fa fa-check"></i><b>7.22.2</b> 主要功能</a></li>
<li class="chapter" data-level="7.22.3" data-path="applications.html"><a href="applications.html#使用场景-1"><i class="fa fa-check"></i><b>7.22.3</b> 使用场景</a></li>
</ul></li>
<li class="chapter" data-level="7.23" data-path="applications.html"><a href="applications.html#assembly-binary-exponentiation"><i class="fa fa-check"></i><b>7.23</b> 22 Assembly Binary Exponentiation</a>
<ul>
<li class="chapter" data-level="7.23.1" data-path="applications.html"><a href="applications.html#合约结构"><i class="fa fa-check"></i><b>7.23.1</b> 合约结构</a></li>
<li class="chapter" data-level="7.23.2" data-path="applications.html"><a href="applications.html#汇编代码解析"><i class="fa fa-check"></i><b>7.23.2</b> 汇编代码解析</a></li>
<li class="chapter" data-level="7.23.3" data-path="applications.html"><a href="applications.html#总结"><i class="fa fa-check"></i><b>7.23.3</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="7.24" data-path="applications.html"><a href="applications.html#merkle-airdrop-空投"><i class="fa fa-check"></i><b>7.24</b> 23 Merkle Airdrop 空投</a>
<ul>
<li class="chapter" data-level="7.24.1" data-path="applications.html"><a href="applications.html#merkle-airdrop"><i class="fa fa-check"></i><b>7.24.1</b> Merkle Airdrop</a></li>
<li class="chapter" data-level="7.24.2" data-path="applications.html"><a href="applications.html#代币合约"><i class="fa fa-check"></i><b>7.24.2</b> 代币合约</a></li>
<li class="chapter" data-level="7.24.3" data-path="applications.html"><a href="applications.html#merkle-证明库"><i class="fa fa-check"></i><b>7.24.3</b> Merkle 证明库</a></li>
<li class="chapter" data-level="7.24.4" data-path="applications.html"><a href="applications.html#测试合约"><i class="fa fa-check"></i><b>7.24.4</b> 测试合约</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html"><i class="fa fa-check"></i><b>8</b> Hacks ，EVM ， test and DeFi</a>
<ul>
<li class="chapter" data-level="8.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#重入攻击漏洞"><i class="fa fa-check"></i><b>8.1</b> 重入攻击漏洞</a></li>
<li class="chapter" data-level="8.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#算术溢出和下溢漏洞"><i class="fa fa-check"></i><b>8.2</b> 算术溢出和下溢漏洞</a></li>
<li class="chapter" data-level="8.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#自销毁-self-destruct"><i class="fa fa-check"></i><b>8.3</b> 自销毁 (Self Destruct)</a></li>
<li class="chapter" data-level="8.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#访问私有数据"><i class="fa fa-check"></i><b>8.4</b> 访问私有数据</a></li>
<li class="chapter" data-level="8.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#代理调用-delegatecall"><i class="fa fa-check"></i><b>8.5</b> 代理调用 (Delegatecall)</a></li>
<li class="chapter" data-level="8.6" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#随机性来源-source-of-randomness"><i class="fa fa-check"></i><b>8.6</b> 随机性来源 (Source of Randomness)</a></li>
<li class="chapter" data-level="8.7" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#拒绝服务-denial-of-service"><i class="fa fa-check"></i><b>8.7</b> 拒绝服务 (Denial of Service)</a></li>
<li class="chapter" data-level="8.8" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#钓鱼攻击与-tx.origin"><i class="fa fa-check"></i><b>8.8</b> 钓鱼攻击与 tx.origin</a>
<ul>
<li class="chapter" data-level="8.8.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#网络钓鱼与-tx.origin"><i class="fa fa-check"></i><b>8.8.1</b> 网络钓鱼与 tx.origin</a></li>
<li class="chapter" data-level="8.8.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#预防技术"><i class="fa fa-check"></i><b>8.8.2</b> 预防技术</a></li>
</ul></li>
<li class="chapter" data-level="8.9" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#隐藏恶意代码的外部合约"><i class="fa fa-check"></i><b>8.9</b> 隐藏恶意代码的外部合约</a>
<ul>
<li class="chapter" data-level="8.9.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#隐藏恶意代码的外部合约-1"><i class="fa fa-check"></i><b>8.9.1</b> 隐藏恶意代码的外部合约</a></li>
<li class="chapter" data-level="8.9.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#预防技术-1"><i class="fa fa-check"></i><b>8.9.2</b> 预防技术</a></li>
</ul></li>
<li class="chapter" data-level="8.10" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#蜂窝陷阱-honeypot"><i class="fa fa-check"></i><b>8.10</b> 蜂窝陷阱 (Honeypot)</a>
<ul>
<li class="chapter" data-level="8.10.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#发生了什么"><i class="fa fa-check"></i><b>8.10.1</b> 发生了什么？</a></li>
<li class="chapter" data-level="8.10.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#结论-1"><i class="fa fa-check"></i><b>8.10.2</b> 结论</a></li>
</ul></li>
<li class="chapter" data-level="8.11" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#前置交易-front-running"><i class="fa fa-check"></i><b>8.11</b> 前置交易 (Front Running)</a>
<ul>
<li class="chapter" data-level="8.11.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#发生了什么-1"><i class="fa fa-check"></i><b>8.11.1</b> 发生了什么？</a></li>
<li class="chapter" data-level="8.11.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#预防措施"><i class="fa fa-check"></i><b>8.11.2</b> 预防措施</a></li>
<li class="chapter" data-level="8.11.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#承诺-揭示方案示例"><i class="fa fa-check"></i><b>8.11.3</b> 承诺-揭示方案示例</a></li>
<li class="chapter" data-level="8.11.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#结论-2"><i class="fa fa-check"></i><b>8.11.4</b> 结论</a></li>
</ul></li>
<li class="chapter" data-level="8.12" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#区块时间戳操控-block-timestamp-manipulation"><i class="fa fa-check"></i><b>8.12</b> 区块时间戳操控 (Block Timestamp Manipulation)</a>
<ul>
<li class="chapter" data-level="8.12.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#示例场景"><i class="fa fa-check"></i><b>8.12.1</b> 示例场景</a></li>
<li class="chapter" data-level="8.12.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#发生了什么-2"><i class="fa fa-check"></i><b>8.12.2</b> 发生了什么？</a></li>
<li class="chapter" data-level="8.12.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#预防措施-1"><i class="fa fa-check"></i><b>8.12.3</b> 预防措施</a></li>
<li class="chapter" data-level="8.12.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-1"><i class="fa fa-check"></i><b>8.12.4</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.13" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#签名重放漏洞-signature-replay-vulnerability"><i class="fa fa-check"></i><b>8.13</b> 签名重放漏洞 (Signature Replay Vulnerability)</a>
<ul>
<li class="chapter" data-level="8.13.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#示例合约"><i class="fa fa-check"></i><b>8.13.1</b> 示例合约</a></li>
<li class="chapter" data-level="8.13.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#发生了什么-3"><i class="fa fa-check"></i><b>8.13.2</b> 发生了什么？</a></li>
<li class="chapter" data-level="8.13.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#预防措施-2"><i class="fa fa-check"></i><b>8.13.3</b> 预防措施</a></li>
<li class="chapter" data-level="8.13.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-2"><i class="fa fa-check"></i><b>8.13.4</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.14" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#绕过合约大小检查-bypass-contract-size-check"><i class="fa fa-check"></i><b>8.14</b> 绕过合约大小检查 (Bypass Contract Size Check)</a>
<ul>
<li class="chapter" data-level="8.14.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#示例合约-1"><i class="fa fa-check"></i><b>8.14.1</b> 示例合约</a></li>
<li class="chapter" data-level="8.14.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#结论-3"><i class="fa fa-check"></i><b>8.14.2</b> 结论</a></li>
</ul></li>
<li class="chapter" data-level="8.15" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#在相同地址部署不同合约-deploy-different-contracts-at-the-same-address"><i class="fa fa-check"></i><b>8.15</b> 在相同地址部署不同合约 (Deploy Different Contracts at the Same Address)</a>
<ul>
<li class="chapter" data-level="8.15.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#示例合约-2"><i class="fa fa-check"></i><b>8.15.1</b> 示例合约</a></li>
<li class="chapter" data-level="8.15.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#攻击流程"><i class="fa fa-check"></i><b>8.15.2</b> 攻击流程</a></li>
<li class="chapter" data-level="8.15.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#结论-4"><i class="fa fa-check"></i><b>8.15.3</b> 结论</a></li>
</ul></li>
<li class="chapter" data-level="8.16" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#vault-inflation-vulnerability"><i class="fa fa-check"></i><b>8.16</b> Vault Inflation Vulnerability</a>
<ul>
<li class="chapter" data-level="8.16.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#攻击示例"><i class="fa fa-check"></i><b>8.16.1</b> 攻击示例</a></li>
<li class="chapter" data-level="8.16.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#保护措施"><i class="fa fa-check"></i><b>8.16.2</b> 保护措施</a></li>
<li class="chapter" data-level="8.16.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#示例合约代码"><i class="fa fa-check"></i><b>8.16.3</b> 示例合约代码</a></li>
<li class="chapter" data-level="8.16.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#结论-5"><i class="fa fa-check"></i><b>8.16.4</b> 结论</a></li>
</ul></li>
<li class="chapter" data-level="8.17" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#weth-permit-vulnerability"><i class="fa fa-check"></i><b>8.17</b> WETH Permit Vulnerability</a>
<ul>
<li class="chapter" data-level="8.17.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#攻击示例-1"><i class="fa fa-check"></i><b>8.17.1</b> 攻击示例</a></li>
<li class="chapter" data-level="8.17.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约代码"><i class="fa fa-check"></i><b>8.17.2</b> 合约代码</a></li>
<li class="chapter" data-level="8.17.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#其他合约"><i class="fa fa-check"></i><b>8.17.3</b> 其他合约</a></li>
<li class="chapter" data-level="8.17.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#结论-6"><i class="fa fa-check"></i><b>8.17.4</b> 结论</a></li>
</ul></li>
<li class="chapter" data-level="8.18" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#echidna"><i class="fa fa-check"></i><b>8.18</b> Echidna</a>
<ul>
<li class="chapter" data-level="8.18.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#测试时间和发送者"><i class="fa fa-check"></i><b>8.18.1</b> 测试时间和发送者</a></li>
</ul></li>
<li class="chapter" data-level="8.19" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#evm-storage"><i class="fa fa-check"></i><b>8.19</b> EVM Storage</a></li>
<li class="chapter" data-level="8.20" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#evm-memory-layout-in-solidity"><i class="fa fa-check"></i><b>8.20</b> EVM Memory Layout in Solidity</a>
<ul>
<li class="chapter" data-level="8.20.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约概述"><i class="fa fa-check"></i><b>8.20.1</b> 合约概述</a></li>
<li class="chapter" data-level="8.20.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-3"><i class="fa fa-check"></i><b>8.20.2</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.21" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v2-swap"><i class="fa fa-check"></i><b>8.21</b> Uniswap V2 Swap</a>
<ul>
<li class="chapter" data-level="8.21.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约和变量定义"><i class="fa fa-check"></i><b>8.21.1</b> 1. 合约和变量定义</a></li>
<li class="chapter" data-level="8.21.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#代币交换函数"><i class="fa fa-check"></i><b>8.21.2</b> 2. 代币交换函数</a></li>
<li class="chapter" data-level="8.21.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#测试合约-1"><i class="fa fa-check"></i><b>8.21.3</b> 3. 测试合约</a></li>
<li class="chapter" data-level="8.21.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-4"><i class="fa fa-check"></i><b>8.21.4</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.22" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v2-add-remove-liquidity"><i class="fa fa-check"></i><b>8.22</b> Uniswap V2 Add Remove Liquidity</a></li>
<li class="chapter" data-level="8.23" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v2-optimal-one-sided-supply"><i class="fa fa-check"></i><b>8.23</b> Uniswap V2 Optimal One Sided Supply</a></li>
<li class="chapter" data-level="8.24" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v2-flash-swap"><i class="fa fa-check"></i><b>8.24</b> Uniswap V2 Flash Swap</a>
<ul>
<li class="chapter" data-level="8.24.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#闪电借贷合约-uniswapv2flashswap"><i class="fa fa-check"></i><b>8.24.1</b> 1. <strong>闪电借贷合约 (UniswapV2FlashSwap)</strong></a></li>
<li class="chapter" data-level="8.24.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义"><i class="fa fa-check"></i><b>8.24.2</b> 2. <strong>接口定义</strong></a></li>
<li class="chapter" data-level="8.24.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#测试合约-uniswapv2flashswaptest"><i class="fa fa-check"></i><b>8.24.3</b> 3. <strong>测试合约 (UniswapV2FlashSwapTest)</strong></a></li>
<li class="chapter" data-level="8.24.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-5"><i class="fa fa-check"></i><b>8.24.4</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.25" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v3-swap-examples"><i class="fa fa-check"></i><b>8.25</b> Uniswap V3 Swap Examples</a>
<ul>
<li class="chapter" data-level="8.25.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v3-单跳交换-uniswapv3singlehopswap"><i class="fa fa-check"></i><b>8.25.1</b> 1. <strong>Uniswap V3 单跳交换 (UniswapV3SingleHopSwap)</strong></a></li>
<li class="chapter" data-level="8.25.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v3-多跳交换-uniswapv3multihopswap"><i class="fa fa-check"></i><b>8.25.2</b> 2. <strong>Uniswap V3 多跳交换 (UniswapV3MultiHopSwap)</strong></a></li>
<li class="chapter" data-level="8.25.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义-1"><i class="fa fa-check"></i><b>8.25.3</b> 3. <strong>接口定义</strong></a></li>
<li class="chapter" data-level="8.25.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-6"><i class="fa fa-check"></i><b>8.25.4</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.26" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v3-liquidity-examples"><i class="fa fa-check"></i><b>8.26</b> Uniswap V3 Liquidity Examples</a>
<ul>
<li class="chapter" data-level="8.26.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约和常量定义"><i class="fa fa-check"></i><b>8.26.1</b> 1. <strong>合约和常量定义</strong></a></li>
<li class="chapter" data-level="8.26.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswapv3liquidity合约"><i class="fa fa-check"></i><b>8.26.2</b> 2. <strong>UniswapV3Liquidity合约</strong></a></li>
<li class="chapter" data-level="8.26.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#inonfungiblepositionmanager接口"><i class="fa fa-check"></i><b>8.26.3</b> 3. <strong><code>INonfungiblePositionManager</code>接口</strong></a></li>
<li class="chapter" data-level="8.26.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#ierc20和iweth接口"><i class="fa fa-check"></i><b>8.26.4</b> 4. <strong><code>IERC20</code>和<code>IWETH</code>接口</strong></a></li>
<li class="chapter" data-level="8.26.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#测试合约-uniswapv3liquiditytest"><i class="fa fa-check"></i><b>8.26.5</b> 5. <strong>测试合约 (UniswapV3LiquidityTest)</strong></a></li>
<li class="chapter" data-level="8.26.6" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-7"><i class="fa fa-check"></i><b>8.26.6</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.27" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v3-flash-loan"><i class="fa fa-check"></i><b>8.27</b> Uniswap V3 Flash Loan</a>
<ul>
<li class="chapter" data-level="8.27.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswapv3flash合约"><i class="fa fa-check"></i><b>8.27.1</b> 1. <strong>UniswapV3Flash合约</strong></a></li>
<li class="chapter" data-level="8.27.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#iuniswapv3pool接口"><i class="fa fa-check"></i><b>8.27.2</b> 2. <strong>IUniswapV3Pool接口</strong></a></li>
<li class="chapter" data-level="8.27.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#ierc20接口"><i class="fa fa-check"></i><b>8.27.3</b> 3. <strong>IERC20接口</strong></a></li>
<li class="chapter" data-level="8.27.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#测试合约-uniswapv3flashtest"><i class="fa fa-check"></i><b>8.27.4</b> 4. <strong>测试合约 (UniswapV3FlashTest)</strong></a></li>
<li class="chapter" data-level="8.27.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-8"><i class="fa fa-check"></i><b>8.27.5</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.28" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v3-flash-swap-arbitrage"><i class="fa fa-check"></i><b>8.28</b> Uniswap V3 Flash Swap Arbitrage</a></li>
<li class="chapter" data-level="8.29" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswap-v3-flash-swap-arbitrage-example"><i class="fa fa-check"></i><b>8.29</b> Uniswap V3 Flash Swap Arbitrage Example</a>
<ul>
<li class="chapter" data-level="8.29.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#uniswapv3flashswap合约"><i class="fa fa-check"></i><b>8.29.1</b> UniswapV3FlashSwap合约</a></li>
<li class="chapter" data-level="8.29.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义-2"><i class="fa fa-check"></i><b>8.29.2</b> 接口定义</a></li>
<li class="chapter" data-level="8.29.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#测试合约-uniswapv3flashtest-1"><i class="fa fa-check"></i><b>8.29.3</b> 测试合约 (UniswapV3FlashTest)</a></li>
<li class="chapter" data-level="8.29.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-9"><i class="fa fa-check"></i><b>8.29.4</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.30" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#chainlink-price-oracle"><i class="fa fa-check"></i><b>8.30</b> Chainlink Price Oracle</a>
<ul>
<li class="chapter" data-level="8.30.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#chainlinkpriceoracle合约"><i class="fa fa-check"></i><b>8.30.1</b> ChainlinkPriceOracle合约</a></li>
<li class="chapter" data-level="8.30.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#aggregatorv3interface接口"><i class="fa fa-check"></i><b>8.30.2</b> AggregatorV3Interface接口</a></li>
<li class="chapter" data-level="8.30.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-10"><i class="fa fa-check"></i><b>8.30.3</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.31" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#dai-proxy-examples"><i class="fa fa-check"></i><b>8.31</b> DAI Proxy Examples</a>
<ul>
<li class="chapter" data-level="8.31.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约声明和常量"><i class="fa fa-check"></i><b>8.31.1</b> 合约声明和常量</a></li>
<li class="chapter" data-level="8.31.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#daiproxy合约"><i class="fa fa-check"></i><b>8.31.2</b> DaiProxy合约</a></li>
<li class="chapter" data-level="8.31.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#函数定义"><i class="fa fa-check"></i><b>8.31.3</b> 函数定义</a></li>
<li class="chapter" data-level="8.31.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义-3"><i class="fa fa-check"></i><b>8.31.4</b> 接口定义</a></li>
<li class="chapter" data-level="8.31.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-11"><i class="fa fa-check"></i><b>8.31.5</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.32" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#staking-rewards"><i class="fa fa-check"></i><b>8.32</b> Staking Rewards</a>
<ul>
<li class="chapter" data-level="8.32.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约声明和状态变量"><i class="fa fa-check"></i><b>8.32.1</b> 合约声明和状态变量</a></li>
<li class="chapter" data-level="8.32.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#奖励相关的变量"><i class="fa fa-check"></i><b>8.32.2</b> 奖励相关的变量</a></li>
<li class="chapter" data-level="8.32.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#用户相关的映射"><i class="fa fa-check"></i><b>8.32.3</b> 用户相关的映射</a></li>
<li class="chapter" data-level="8.32.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总质押量和用户质押记录"><i class="fa fa-check"></i><b>8.32.4</b> 总质押量和用户质押记录</a></li>
<li class="chapter" data-level="8.32.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#构造函数-5"><i class="fa fa-check"></i><b>8.32.5</b> 构造函数</a></li>
<li class="chapter" data-level="8.32.6" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#修饰符"><i class="fa fa-check"></i><b>8.32.6</b> 修饰符</a></li>
<li class="chapter" data-level="8.32.7" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#奖励计算函数"><i class="fa fa-check"></i><b>8.32.7</b> 奖励计算函数</a></li>
<li class="chapter" data-level="8.32.8" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#质押和提取函数"><i class="fa fa-check"></i><b>8.32.8</b> 质押和提取函数</a></li>
<li class="chapter" data-level="8.32.9" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#奖励领取和计算"><i class="fa fa-check"></i><b>8.32.9</b> 奖励领取和计算</a></li>
<li class="chapter" data-level="8.32.10" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#管理函数"><i class="fa fa-check"></i><b>8.32.10</b> 管理函数</a></li>
<li class="chapter" data-level="8.32.11" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#辅助函数"><i class="fa fa-check"></i><b>8.32.11</b> 辅助函数</a></li>
<li class="chapter" data-level="8.32.12" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义-4"><i class="fa fa-check"></i><b>8.32.12</b> 接口定义</a></li>
<li class="chapter" data-level="8.32.13" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-12"><i class="fa fa-check"></i><b>8.32.13</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.33" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#discrete-staking-rewards"><i class="fa fa-check"></i><b>8.33</b> Discrete Staking Rewards</a>
<ul>
<li class="chapter" data-level="8.33.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约声明和状态变量-1"><i class="fa fa-check"></i><b>8.33.1</b> 合约声明和状态变量</a></li>
<li class="chapter" data-level="8.33.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#奖励相关变量"><i class="fa fa-check"></i><b>8.33.2</b> 奖励相关变量</a></li>
<li class="chapter" data-level="8.33.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#构造函数-6"><i class="fa fa-check"></i><b>8.33.3</b> 构造函数</a></li>
<li class="chapter" data-level="8.33.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#更新奖励指数"><i class="fa fa-check"></i><b>8.33.4</b> 更新奖励指数</a></li>
<li class="chapter" data-level="8.33.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#计算奖励"><i class="fa fa-check"></i><b>8.33.5</b> 计算奖励</a></li>
<li class="chapter" data-level="8.33.6" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#计算已赚取的奖励"><i class="fa fa-check"></i><b>8.33.6</b> 计算已赚取的奖励</a></li>
<li class="chapter" data-level="8.33.7" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#更新用户奖励"><i class="fa fa-check"></i><b>8.33.7</b> 更新用户奖励</a></li>
<li class="chapter" data-level="8.33.8" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#质押和提取函数-1"><i class="fa fa-check"></i><b>8.33.8</b> 质押和提取函数</a></li>
<li class="chapter" data-level="8.33.9" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#领取奖励函数"><i class="fa fa-check"></i><b>8.33.9</b> 领取奖励函数</a></li>
<li class="chapter" data-level="8.33.10" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义-5"><i class="fa fa-check"></i><b>8.33.10</b> 接口定义</a></li>
<li class="chapter" data-level="8.33.11" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-13"><i class="fa fa-check"></i><b>8.33.11</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.34" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#vault"><i class="fa fa-check"></i><b>8.34</b> Vault</a>
<ul>
<li class="chapter" data-level="8.34.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约声明和状态变量-2"><i class="fa fa-check"></i><b>8.34.1</b> 合约声明和状态变量</a></li>
<li class="chapter" data-level="8.34.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#铸造和销毁股份"><i class="fa fa-check"></i><b>8.34.2</b> 铸造和销毁股份</a></li>
<li class="chapter" data-level="8.34.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#存款功能"><i class="fa fa-check"></i><b>8.34.3</b> 存款功能</a></li>
<li class="chapter" data-level="8.34.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#提取功能"><i class="fa fa-check"></i><b>8.34.4</b> 提取功能</a></li>
<li class="chapter" data-level="8.34.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义-6"><i class="fa fa-check"></i><b>8.34.5</b> 接口定义</a></li>
<li class="chapter" data-level="8.34.6" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-14"><i class="fa fa-check"></i><b>8.34.6</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.35" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#constant-sum-amm"><i class="fa fa-check"></i><b>8.35</b> Constant Sum AMM</a>
<ul>
<li class="chapter" data-level="8.35.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约声明和状态变量-3"><i class="fa fa-check"></i><b>8.35.1</b> 合约声明和状态变量</a></li>
<li class="chapter" data-level="8.35.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#铸造和销毁股份-1"><i class="fa fa-check"></i><b>8.35.2</b> 铸造和销毁股份</a></li>
<li class="chapter" data-level="8.35.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#更新储备量"><i class="fa fa-check"></i><b>8.35.3</b> 更新储备量</a></li>
<li class="chapter" data-level="8.35.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#交换功能-1"><i class="fa fa-check"></i><b>8.35.4</b> 交换功能</a></li>
<li class="chapter" data-level="8.35.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#添加流动性"><i class="fa fa-check"></i><b>8.35.5</b> 添加流动性</a></li>
<li class="chapter" data-level="8.35.6" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#移除流动性"><i class="fa fa-check"></i><b>8.35.6</b> 移除流动性</a></li>
<li class="chapter" data-level="8.35.7" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义-7"><i class="fa fa-check"></i><b>8.35.7</b> 接口定义</a></li>
<li class="chapter" data-level="8.35.8" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-15"><i class="fa fa-check"></i><b>8.35.8</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.36" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#constant-product-amm"><i class="fa fa-check"></i><b>8.36</b> Constant Product AMM</a>
<ul>
<li class="chapter" data-level="8.36.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约结构-1"><i class="fa fa-check"></i><b>8.36.1</b> 合约结构</a></li>
<li class="chapter" data-level="8.36.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#内部函数"><i class="fa fa-check"></i><b>8.36.2</b> 内部函数</a></li>
<li class="chapter" data-level="8.36.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#外部函数"><i class="fa fa-check"></i><b>8.36.3</b> 外部函数</a></li>
<li class="chapter" data-level="8.36.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#辅助函数-1"><i class="fa fa-check"></i><b>8.36.4</b> 辅助函数</a></li>
<li class="chapter" data-level="8.36.5" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#接口定义-8"><i class="fa fa-check"></i><b>8.36.5</b> 接口定义</a></li>
<li class="chapter" data-level="8.36.6" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-16"><i class="fa fa-check"></i><b>8.36.6</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.37" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#stable-swap-amm"><i class="fa fa-check"></i><b>8.37</b> Stable Swap AMM</a>
<ul>
<li class="chapter" data-level="8.37.1" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#合约结构与功能概述"><i class="fa fa-check"></i><b>8.37.1</b> 合约结构与功能概述</a></li>
<li class="chapter" data-level="8.37.2" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#主要功能-5"><i class="fa fa-check"></i><b>8.37.2</b> 主要功能</a></li>
<li class="chapter" data-level="8.37.3" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#计算方法"><i class="fa fa-check"></i><b>8.37.3</b> 计算方法</a></li>
<li class="chapter" data-level="8.37.4" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#总结-17"><i class="fa fa-check"></i><b>8.37.4</b> 总结</a></li>
</ul></li>
<li class="chapter" data-level="8.38" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#r-markdown"><i class="fa fa-check"></i><b>8.38</b> R Markdown</a></li>
<li class="chapter" data-level="8.39" data-path="hacks-evm-test-and-defi.html"><a href="hacks-evm-test-and-defi.html#including-plots"><i class="fa fa-check"></i><b>8.39</b> Including Plots</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank"https://github.com/Token-Economy-Book</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Token Economy: How the Web3 reinvents the Internet</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="applications" class="section level1 hasAnchor" number="7">
<h1><span class="header-section-number">Chapter 7</span> Applications<a href="applications.html#applications" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="ether-wallet" class="section level2 hasAnchor" number="7.1">
<h2><span class="header-section-number">7.1</span> 1 Ether Wallet<a href="applications.html#ether-wallet" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>一个基本钱包的例子。</p>
<ul>
<li><p>任何人都可以发送ETH。</p></li>
<li><p>只有所有者可以退出。</p></li>
</ul>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract EtherWallet {
    address payable public owner;

    constructor() {
        owner = payable(msg.sender);
    }

    receive() external payable {}

    function withdraw(uint256 _amount) external {
        require(msg.sender == owner, &quot;caller is not owner&quot;);
        payable(msg.sender).transfer(_amount);
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
</code></pre>
</div>
<div id="多签名钱包" class="section level2 hasAnchor" number="7.2">
<h2><span class="header-section-number">7.2</span> 2 多签名钱包<a href="applications.html#多签名钱包" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>让我们创建一个多签名钱包。这是规格说明。</p>
<p>钱包的主人可以
1. 提交交易
2. 批准和撤销对未决交易的批准
3. 在获得足够多的所有者批准后，任何人都可以执行交易。</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MultiSigWallet {
    event Deposit(address indexed sender, uint256 amount, uint256 balance);
    event SubmitTransaction(
        address indexed owner,
        uint256 indexed txIndex,
        address indexed to,
        uint256 value,
        bytes data
    );
    event ConfirmTransaction(address indexed owner, uint256 indexed txIndex);
    event RevokeConfirmation(address indexed owner, uint256 indexed txIndex);
    event ExecuteTransaction(address indexed owner, uint256 indexed txIndex);

    address[] public owners;
    mapping(address =&gt; bool) public isOwner;
    uint256 public numConfirmationsRequired;

    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 numConfirmations;
    }

    // mapping from tx index =&gt; owner =&gt; bool
    mapping(uint256 =&gt; mapping(address =&gt; bool)) public isConfirmed;

    Transaction[] public transactions;

    modifier onlyOwner() {
        require(isOwner[msg.sender], &quot;not owner&quot;);
        _;
    }

    modifier txExists(uint256 _txIndex) {
        require(_txIndex &lt; transactions.length, &quot;tx does not exist&quot;);
        _;
    }

    modifier notExecuted(uint256 _txIndex) {
        require(!transactions[_txIndex].executed, &quot;tx already executed&quot;);
        _;
    }

    modifier notConfirmed(uint256 _txIndex) {
        require(!isConfirmed[_txIndex][msg.sender], &quot;tx already confirmed&quot;);
        _;
    }

    constructor(address[] memory _owners, uint256 _numConfirmationsRequired) {
        require(_owners.length &gt; 0, &quot;owners required&quot;);
        require(
            _numConfirmationsRequired &gt; 0
                &amp;&amp; _numConfirmationsRequired &lt;= _owners.length,
            &quot;invalid number of required confirmations&quot;
        );

        for (uint256 i = 0; i &lt; _owners.length; i++) {
            address owner = _owners[i];

            require(owner != address(0), &quot;invalid owner&quot;);
            require(!isOwner[owner], &quot;owner not unique&quot;);

            isOwner[owner] = true;
            owners.push(owner);
        }

        numConfirmationsRequired = _numConfirmationsRequired;
    }

    receive() external payable {
        emit Deposit(msg.sender, msg.value, address(this).balance);
    }

    function submitTransaction(address _to, uint256 _value, bytes memory _data)
        public
        onlyOwner
    {
        uint256 txIndex = transactions.length;

        transactions.push(
            Transaction({
                to: _to,
                value: _value,
                data: _data,
                executed: false,
                numConfirmations: 0
            })
        );

        emit SubmitTransaction(msg.sender, txIndex, _to, _value, _data);
    }

    function confirmTransaction(uint256 _txIndex)
        public
        onlyOwner
        txExists(_txIndex)
        notExecuted(_txIndex)
        notConfirmed(_txIndex)
    {
        Transaction storage transaction = transactions[_txIndex];
        transaction.numConfirmations += 1;
        isConfirmed[_txIndex][msg.sender] = true;

        emit ConfirmTransaction(msg.sender, _txIndex);
    }

    function executeTransaction(uint256 _txIndex)
        public
        onlyOwner
        txExists(_txIndex)
        notExecuted(_txIndex)
    {
        Transaction storage transaction = transactions[_txIndex];

        require(
            transaction.numConfirmations &gt;= numConfirmationsRequired,
            &quot;cannot execute tx&quot;
        );

        transaction.executed = true;

        (bool success,) =
            transaction.to.call{value: transaction.value}(transaction.data);
        require(success, &quot;tx failed&quot;);

        emit ExecuteTransaction(msg.sender, _txIndex);
    }

    function revokeConfirmation(uint256 _txIndex)
        public
        onlyOwner
        txExists(_txIndex)
        notExecuted(_txIndex)
    {
        Transaction storage transaction = transactions[_txIndex];

        require(isConfirmed[_txIndex][msg.sender], &quot;tx not confirmed&quot;);

        transaction.numConfirmations -= 1;
        isConfirmed[_txIndex][msg.sender] = false;

        emit RevokeConfirmation(msg.sender, _txIndex);
    }

    function getOwners() public view returns (address[] memory) {
        return owners;
    }

    function getTransactionCount() public view returns (uint256) {
        return transactions.length;
    }

    function getTransaction(uint256 _txIndex)
        public
        view
        returns (
            address to,
            uint256 value,
            bytes memory data,
            bool executed,
            uint256 numConfirmations
        )
    {
        Transaction storage transaction = transactions[_txIndex];

        return (
            transaction.to,
            transaction.value,
            transaction.data,
            transaction.executed,
            transaction.numConfirmations
        );
    }
}
</code></pre>
</div>
<div id="merkle树" class="section level2 hasAnchor" number="7.3">
<h2><span class="header-section-number">7.3</span> 3 Merkle树<a href="applications.html#merkle树" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>默克尔树允许以加密方式证明包含某个元素</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MerkleProof {
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf,
        uint256 index
    ) public pure returns (bool) {
        bytes32 hash = leaf;

        for (uint256 i = 0; i &lt; proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (index % 2 == 0) {
                hash = keccak256(abi.encodePacked(hash, proofElement));
            } else {
                hash = keccak256(abi.encodePacked(proofElement, hash));
            }

            index = index / 2;
        }

        return hash == root;
    }
}

contract TestMerkleProof is MerkleProof {
    bytes32[] public hashes;

    constructor() {
        string[4] memory transactions =
            [&quot;alice -&gt; bob&quot;, &quot;bob -&gt; dave&quot;, &quot;carol -&gt; alice&quot;, &quot;dave -&gt; bob&quot;];

        for (uint256 i = 0; i &lt; transactions.length; i++) {
            hashes.push(keccak256(abi.encodePacked(transactions[i])));
        }

        uint256 n = transactions.length;
        uint256 offset = 0;

        while (n &gt; 0) {
            for (uint256 i = 0; i &lt; n - 1; i += 2) {
                hashes.push(
                    keccak256(
                        abi.encodePacked(
                            hashes[offset + i], hashes[offset + i + 1]
                        )
                    )
                );
            }
            offset += n;
            n = n / 2;
        }
    }

    function getRoot() public view returns (bytes32) {
        return hashes[hashes.length - 1];
    }

    /* verify
    3rd leaf
    0xdca3326ad7e8121bf9cf9c12333e6b2271abe823ec9edfe42f813b1e768fa57b

    root
    0xcc086fcc038189b4641db2cc4f1de3bb132aefbd65d510d817591550937818c7

    index
    2

    proof
    0x8da9e1c820f9dbd1589fd6585872bc1063588625729e7ab0797cfc63a00bd950
    0x995788ffc103b987ad50f5e5707fd094419eb12d9552cc423bd0cd86a3861433
    */
}
</code></pre>
</div>
<div id="iterable映射" class="section level2 hasAnchor" number="7.4">
<h2><span class="header-section-number">7.4</span> 4 Iterable映射<a href="applications.html#iterable映射" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>下面是一个如何创建可迭代映射的示例。</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

library IterableMapping {
    // Iterable mapping from address to uint;
    struct Map {
        address[] keys;
        mapping(address =&gt; uint256) values;
        mapping(address =&gt; uint256) indexOf;
        mapping(address =&gt; bool) inserted;
    }

    function get(Map storage map, address key) public view returns (uint256) {
        return map.values[key];
    }

    function getKeyAtIndex(Map storage map, uint256 index)
        public
        view
        returns (address)
    {
        return map.keys[index];
    }

    function size(Map storage map) public view returns (uint256) {
        return map.keys.length;
    }

    function set(Map storage map, address key, uint256 val) public {
        if (map.inserted[key]) {
            map.values[key] = val;
        } else {
            map.inserted[key] = true;
            map.values[key] = val;
            map.indexOf[key] = map.keys.length;
            map.keys.push(key);
        }
    }

    function remove(Map storage map, address key) public {
        if (!map.inserted[key]) {
            return;
        }

        delete map.inserted[key];
        delete map.values[key];

        uint256 index = map.indexOf[key];
        address lastKey = map.keys[map.keys.length - 1];

        map.indexOf[lastKey] = index;
        delete map.indexOf[key];

        map.keys[index] = lastKey;
        map.keys.pop();
    }
}

contract TestIterableMap {
    using IterableMapping for IterableMapping.Map;

    IterableMapping.Map private map;

    function testIterableMap() public {
        map.set(address(0), 0);
        map.set(address(1), 100);
        map.set(address(2), 200); // insert
        map.set(address(2), 200); // update
        map.set(address(3), 300);

        for (uint256 i = 0; i &lt; map.size(); i++) {
            address key = map.getKeyAtIndex(i);
            assert(map.get(key) == i * 100);
        }

        map.remove(address(1));

        // keys = [address(0), address(3), address(2)]
        assert(map.size() == 3);
        assert(map.getKeyAtIndex(0) == address(0));
        assert(map.getKeyAtIndex(1) == address(3));
        assert(map.getKeyAtIndex(2) == address(2));
    }
}
</code></pre>
</div>
<div id="erc20-标准" class="section level2 hasAnchor" number="7.5">
<h2><span class="header-section-number">7.5</span> 5 ERC20 标准<a href="applications.html#erc20-标准" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="erc20-标准-1" class="section level3 hasAnchor" number="7.5.1">
<h3><span class="header-section-number">7.5.1</span> ERC20 标准<a href="applications.html#erc20-标准-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>任何遵循 ERC20 标准的合约都是 ERC20 代币。</p>
<p>ERC20 代币提供以下功能：</p>
<ul>
<li>转账代币</li>
<li>允许他人代表代币持有者转账</li>
</ul>
<p>以下是 ERC20 的接口：</p>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}</code></pre>
</div>
<div id="erc20-代币合约示例" class="section level3 hasAnchor" number="7.5.2">
<h3><span class="header-section-number">7.5.2</span> ERC20 代币合约示例<a href="applications.html#erc20-代币合约示例" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import &quot;./IERC20.sol&quot;;

contract ERC20 is IERC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    uint256 public totalSupply;
    mapping(address =&gt; uint256) public balanceOf;
    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function _mint(address to, uint256 amount) internal {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal {
        balanceOf[from] -= amount;
        totalSupply -= amount;
        emit Transfer(from, address(0), amount);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external {
        _burn(from, amount);
    }
}</code></pre>
</div>
<div id="创建您自己的-erc20-代币" class="section level3 hasAnchor" number="7.5.3">
<h3><span class="header-section-number">7.5.3</span> 创建您自己的 ERC20 代币<a href="applications.html#创建您自己的-erc20-代币" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>使用 OpenZeppelin 创建自己的 ERC20 代币非常简单。</p>
<p>以下是一个示例：</p>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import &quot;./ERC20.sol&quot;;

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol, uint8 decimals)
        ERC20(name, symbol, decimals)
    {
        // 向 msg.sender 发行 100 个代币
        // 类似于
        // 1 美元 = 100 分
        // 1 代币 = 1 * (10 ** decimals)
        _mint(msg.sender, 100 * 10 ** uint256(decimals));
    }
}</code></pre>
</div>
<div id="代币交换合约" class="section level3 hasAnchor" number="7.5.4">
<h3><span class="header-section-number">7.5.4</span> 代币交换合约<a href="applications.html#代币交换合约" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>以下是一个示例合约 <code>TokenSwap</code>，用于交换一种 ERC20 代币为另一种。</p>
<p>该合约将通过调用 <code>transferFrom(address sender, address recipient, uint256 amount)</code> 来交换代币，该调用会将代币从发送者转移到接收者。</p>
<p>为了确保 <code>transferFrom</code> 成功，发送者必须：</p>
<ul>
<li>在其余额中拥有超过交换金额的代币</li>
<li>通过调用 <code>approve</code> 允许 <code>TokenSwap</code> 提取交换金额的代币</li>
</ul>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import &quot;./IERC20.sol&quot;;

/*
如何交换代币

1. Alice 拥有 100 个来自 AliceCoin 的代币，这是一个 ERC20 代币。
2. Bob 拥有 100 个来自 BobCoin 的代币，这也是一个 ERC20 代币。
3. Alice 和 Bob 想要交换 10 个 AliceCoin 以换取 20 个 BobCoin。
4. Alice 或 Bob 部署 `TokenSwap`
5. Alice 授权 `TokenSwap` 提取 10 个 AliceCoin
6. Bob 授权 `TokenSwap` 提取 20 个 BobCoin
7. Alice 或 Bob 调用 `TokenSwap.swap()`
8. Alice 和 Bob 成功交换了代币。
*/

contract TokenSwap {
    IERC20 public token1;
    address public owner1;
    uint256 public amount1;
    IERC20 public token2;
    address public owner2;
    uint256 public amount2;

    constructor(
        address _token1,
        address _owner1,
        uint256 _amount1,
        address _token2,
        address _owner2,
        uint256 _amount2
    ) {
        token1 = IERC20(_token1);
        owner1 = _owner1;
        amount1 = _amount1;
        token2 = IERC20(_token2);
        owner2 = _owner2;
        amount2 = _amount2;
    }

    function swap() public {
        require(msg.sender == owner1 || msg.sender == owner2, &quot;Not authorized&quot;);
        require(token1.allowance(owner1, address(this)) &gt;= amount1, &quot;Token 1 allowance too low&quot;);
        require(token2.allowance(owner2, address(this)) &gt;= amount2, &quot;Token 2 allowance too low&quot;);

        _safeTransferFrom(token1, owner1, owner2, amount1);
        _safeTransferFrom(token2, owner2, owner1, amount2);
    }

    function _safeTransferFrom(
        IERC20 token,
        address sender,
        address recipient,
        uint256 amount
    ) private {
        bool sent = token.transferFrom(sender, recipient, amount);
        require(sent, &quot;Token transfer failed&quot;);
    }
}</code></pre>
<p>以上是 ERC20 标准及其实现的完整示例，涵盖了创建、管理和交换代币的基本功能。</p>
</div>
</div>
<div id="erc721" class="section level2 hasAnchor" number="7.6">
<h2><span class="header-section-number">7.6</span> 6 ERC721<a href="applications.html#erc721" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="erc721-标准简介" class="section level3 hasAnchor" number="7.6.1">
<h3><span class="header-section-number">7.6.1</span> ERC721 标准简介<a href="applications.html#erc721-标准简介" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>ERC721 是一种非同质化代币（NFT）标准，用于在以太坊区块链上创建独特且不可互换的代币。与 ERC20 标准的同质化代币（如法定货币或某种代币）不同，ERC721 代币每个都有独特的属性和价值，使其适用于数字艺术、收藏品、游戏资产等场景。</p>
</div>
<div id="主要特点" class="section level3 hasAnchor" number="7.6.2">
<h3><span class="header-section-number">7.6.2</span> 主要特点<a href="applications.html#主要特点" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><strong>唯一性</strong>：每个 ERC721 代币都有一个唯一的标识符（Token ID），使其在区块链上不可替代。</li>
<li><strong>所有权管理</strong>：ERC721 标准提供了跟踪代币所有权的机制，可以在不同的用户之间转移代币。</li>
<li><strong>智能合约</strong>：ERC721 代币的创建和管理通过智能合约实现，支持在合约中定义代币的特性和功能。</li>
<li><strong>可扩展性</strong>：可以根据需求扩展代币的功能，例如添加元数据（如艺术品的描述、创作者信息等）。</li>
</ol>
</div>
<div id="erc721-接口" class="section level3 hasAnchor" number="7.6.3">
<h3><span class="header-section-number">7.6.3</span> ERC721 接口<a href="applications.html#erc721-接口" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>以下是 ERC721 的基本接口示例：</p>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC721 {
    function balanceOf(address owner) external view returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address);
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}</code></pre>
</div>
<div id="应用场景" class="section level3 hasAnchor" number="7.6.4">
<h3><span class="header-section-number">7.6.4</span> 应用场景<a href="applications.html#应用场景" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li><strong>数字艺术</strong>：艺术家可以创建和销售独一无二的数字艺术作品。</li>
<li><strong>游戏资产</strong>：玩家可以拥有和交易游戏中的虚拟物品，如角色、皮肤和武器。</li>
<li><strong>收藏品</strong>：如数字卡片、虚拟土地等，允许用户收藏和交易独特的资产。</li>
</ul>
<p>ERC721 标准的出现推动了 NFT 生态系统的发展，使数字资产的独特性和稀缺性得到了有效保障。</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC165 {
    function supportsInterface(bytes4 interfaceID)
        external
        view
        returns (bool);
}

interface IERC721 is IERC165 {
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId)
        external;
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId)
        external
        view
        returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator)
        external
        view
        returns (bool);
}

interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

contract ERC721 is IERC721 {
    event Transfer(
        address indexed from, address indexed to, uint256 indexed id
    );
    event Approval(
        address indexed owner, address indexed spender, uint256 indexed id
    );
    event ApprovalForAll(
        address indexed owner, address indexed operator, bool approved
    );

    // Mapping from token ID to owner address
    mapping(uint256 =&gt; address) internal _ownerOf;

    // Mapping owner address to token count
    mapping(address =&gt; uint256) internal _balanceOf;

    // Mapping from token ID to approved address
    mapping(uint256 =&gt; address) internal _approvals;

    // Mapping from owner to operator approvals
    mapping(address =&gt; mapping(address =&gt; bool)) public isApprovedForAll;

    function supportsInterface(bytes4 interfaceId)
        external
        pure
        returns (bool)
    {
        return interfaceId == type(IERC721).interfaceId
            || interfaceId == type(IERC165).interfaceId;
    }

    function ownerOf(uint256 id) external view returns (address owner) {
        owner = _ownerOf[id];
        require(owner != address(0), &quot;token doesn&#39;t exist&quot;);
    }

    function balanceOf(address owner) external view returns (uint256) {
        require(owner != address(0), &quot;owner = zero address&quot;);
        return _balanceOf[owner];
    }

    function setApprovalForAll(address operator, bool approved) external {
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function approve(address spender, uint256 id) external {
        address owner = _ownerOf[id];
        require(
            msg.sender == owner || isApprovedForAll[owner][msg.sender],
            &quot;not authorized&quot;
        );

        _approvals[id] = spender;

        emit Approval(owner, spender, id);
    }

    function getApproved(uint256 id) external view returns (address) {
        require(_ownerOf[id] != address(0), &quot;token doesn&#39;t exist&quot;);
        return _approvals[id];
    }

    function _isApprovedOrOwner(address owner, address spender, uint256 id)
        internal
        view
        returns (bool)
    {
        return (
            spender == owner || isApprovedForAll[owner][spender]
                || spender == _approvals[id]
        );
    }

    function transferFrom(address from, address to, uint256 id) public {
        require(from == _ownerOf[id], &quot;from != owner&quot;);
        require(to != address(0), &quot;transfer to zero address&quot;);

        require(_isApprovedOrOwner(from, msg.sender, id), &quot;not authorized&quot;);

        _balanceOf[from]--;
        _balanceOf[to]++;
        _ownerOf[id] = to;

        delete _approvals[id];

        emit Transfer(from, to, id);
    }

    function safeTransferFrom(address from, address to, uint256 id) external {
        transferFrom(from, to, id);

        require(
            to.code.length == 0
                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, &quot;&quot;)
                    == IERC721Receiver.onERC721Received.selector,
            &quot;unsafe recipient&quot;
        );
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        bytes calldata data
    ) external {
        transferFrom(from, to, id);

        require(
            to.code.length == 0
                || IERC721Receiver(to).onERC721Received(msg.sender, from, id, data)
                    == IERC721Receiver.onERC721Received.selector,
            &quot;unsafe recipient&quot;
        );
    }

    function _mint(address to, uint256 id) internal {
        require(to != address(0), &quot;mint to zero address&quot;);
        require(_ownerOf[id] == address(0), &quot;already minted&quot;);

        _balanceOf[to]++;
        _ownerOf[id] = to;

        emit Transfer(address(0), to, id);
    }

    function _burn(uint256 id) internal {
        address owner = _ownerOf[id];
        require(owner != address(0), &quot;not minted&quot;);

        _balanceOf[owner] -= 1;

        delete _ownerOf[id];
        delete _approvals[id];

        emit Transfer(owner, address(0), id);
    }
}

contract MyNFT is ERC721 {
    function mint(address to, uint256 id) external {
        _mint(to, id);
    }

    function burn(uint256 id) external {
        require(msg.sender == _ownerOf[id], &quot;not owner&quot;);
        _burn(id);
    }
}
</code></pre>
</div>
</div>
<div id="erc1155" class="section level2 hasAnchor" number="7.7">
<h2><span class="header-section-number">7.7</span> 7 ERC1155<a href="applications.html#erc1155" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>ERC1155 是一种多代币标准，允许在同一个合约中同时管理同质化代币（如 ERC20）和非同质化代币（如 ERC721）。该标准旨在提高区块链应用的灵活性和效率，特别是在游戏和数字资产领域。</p>
<div id="主要特点-1" class="section level3 hasAnchor" number="7.7.1">
<h3><span class="header-section-number">7.7.1</span> 主要特点<a href="applications.html#主要特点-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p><strong>多代币支持</strong>：ERC1155 合约可以同时管理多种类型的代币，用户可以在同一合约中创建和转移不同种类的代币，降低了合约部署和交易成本。</p></li>
<li><p><strong>批量操作</strong>：支持批量转移和批量查询功能，可以一次性处理多个代币的转移，提高了交易效率。例如，可以同时转移多种资产，而不必逐一操作。</p></li>
<li><p><strong>元数据支持</strong>：ERC1155 支持为每种代币提供元数据，允许开发者描述代币的属性和功能，从而增强用户体验。</p></li>
<li><p><strong>更低的 gas 成本</strong>：由于批量处理和共享合约的特性，相比于单独的 ERC721 或 ERC20 合约，ERC1155 可以显著降低交易成本。</p></li>
</ol>
</div>
<div id="erc1155-接口" class="section level3 hasAnchor" number="7.7.2">
<h3><span class="header-section-number">7.7.2</span> ERC1155 接口<a href="applications.html#erc1155-接口" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>以下是 ERC1155 的基本接口示例：</p>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC1155 {
    function balanceOf(address account, uint256 id) external view returns (uint256);
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address account, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
}</code></pre>
</div>
<div id="应用场景-1" class="section level3 hasAnchor" number="7.7.3">
<h3><span class="header-section-number">7.7.3</span> 应用场景<a href="applications.html#应用场景-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li><p><strong>游戏行业</strong>：在游戏中，开发者可以使用 ERC1155 创建多种游戏资产，如角色、道具和虚拟货币，用户可以在同一合约中交易和管理这些资产。</p></li>
<li><p><strong>数字艺术</strong>：艺术家可以发布同时具有可替代性和不可替代性的艺术作品，支持不同形式的艺术作品，如限量版和独特作品。</p></li>
<li><p><strong>收藏品</strong>：支持不同类型的收藏品，用户可以在同一合约中收藏和交易各种类型的资产。</p></li>
</ul>
<p>ERC1155 标准的引入大大增强了区块链资产的灵活性和可操作性，推动了 NFT 生态系统的多样化发展。</p>
<pre><code>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC1155 {
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external;
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external;
    function balanceOf(address owner, uint256 id)
        external
        view
        returns (uint256);
    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address owner, address operator)
        external
        view
        returns (bool);
}

interface IERC1155TokenReceiver {
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}

contract ERC1155 is IERC1155 {
    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 value
    );
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );
    event ApprovalForAll(
        address indexed owner, address indexed operator, bool approved
    );
    event URI(string value, uint256 indexed id);

    // owner =&gt; id =&gt; balance
    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public balanceOf;
    // owner =&gt; operator =&gt; approved
    mapping(address =&gt; mapping(address =&gt; bool)) public isApprovedForAll;

    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory balances)
    {
        require(owners.length == ids.length, &quot;owners length != ids length&quot;);

        balances = new uint256[](owners.length);

        unchecked {
            for (uint256 i = 0; i &lt; owners.length; i++) {
                balances[i] = balanceOf[owners[i]][ids[i]];
            }
        }
    }

    function setApprovalForAll(address operator, bool approved) external {
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external {
        require(
            msg.sender == from || isApprovedForAll[from][msg.sender],
            &quot;not approved&quot;
        );
        require(to != address(0), &quot;to = 0 address&quot;);

        balanceOf[from][id] -= value;
        balanceOf[to][id] += value;

        emit TransferSingle(msg.sender, from, to, id, value);

        if (to.code.length &gt; 0) {
            require(
                IERC1155TokenReceiver(to).onERC1155Received(
                    msg.sender, from, id, value, data
                ) == IERC1155TokenReceiver.onERC1155Received.selector,
                &quot;unsafe transfer&quot;
            );
        }
    }

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external {
        require(
            msg.sender == from || isApprovedForAll[from][msg.sender],
            &quot;not approved&quot;
        );
        require(to != address(0), &quot;to = 0 address&quot;);
        require(ids.length == values.length, &quot;ids length != values length&quot;);

        for (uint256 i = 0; i &lt; ids.length; i++) {
            balanceOf[from][ids[i]] -= values[i];
            balanceOf[to][ids[i]] += values[i];
        }

        emit TransferBatch(msg.sender, from, to, ids, values);

        if (to.code.length &gt; 0) {
            require(
                IERC1155TokenReceiver(to).onERC1155BatchReceived(
                    msg.sender, from, ids, values, data
                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,
                &quot;unsafe transfer&quot;
            );
        }
    }

    // ERC165
    function supportsInterface(bytes4 interfaceId)
        external
        view
        returns (bool)
    {
        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165
            || interfaceId == 0xd9b67a26 // ERC165 Interface ID for ERC1155
            || interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI
    }

    // ERC1155 Metadata URI
    function uri(uint256 id) public view virtual returns (string memory) {}

    // Internal functions
    function _mint(address to, uint256 id, uint256 value, bytes memory data)
        internal
    {
        require(to != address(0), &quot;to = 0 address&quot;);

        balanceOf[to][id] += value;

        emit TransferSingle(msg.sender, address(0), to, id, value);

        if (to.code.length &gt; 0) {
            require(
                IERC1155TokenReceiver(to).onERC1155Received(
                    msg.sender, address(0), id, value, data
                ) == IERC1155TokenReceiver.onERC1155Received.selector,
                &quot;unsafe transfer&quot;
            );
        }
    }

    function _batchMint(
        address to,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) internal {
        require(to != address(0), &quot;to = 0 address&quot;);
        require(ids.length == values.length, &quot;ids length != values length&quot;);

        for (uint256 i = 0; i &lt; ids.length; i++) {
            balanceOf[to][ids[i]] += values[i];
        }

        emit TransferBatch(msg.sender, address(0), to, ids, values);

        if (to.code.length &gt; 0) {
            require(
                IERC1155TokenReceiver(to).onERC1155BatchReceived(
                    msg.sender, address(0), ids, values, data
                ) == IERC1155TokenReceiver.onERC1155BatchReceived.selector,
                &quot;unsafe transfer&quot;
            );
        }
    }

    function _burn(address from, uint256 id, uint256 value) internal {
        require(from != address(0), &quot;from = 0 address&quot;);
        balanceOf[from][id] -= value;
        emit TransferSingle(msg.sender, from, address(0), id, value);
    }

    function _batchBurn(
        address from,
        uint256[] calldata ids,
        uint256[] calldata values
    ) internal {
        require(from != address(0), &quot;from = 0 address&quot;);
        require(ids.length == values.length, &quot;ids length != values length&quot;);

        for (uint256 i = 0; i &lt; ids.length; i++) {
            balanceOf[from][ids[i]] -= values[i];
        }

        emit TransferBatch(msg.sender, from, address(0), ids, values);
    }
}

contract MyMultiToken is ERC1155 {
    function mint(uint256 id, uint256 value, bytes memory data) external {
        _mint(msg.sender, id, value, data);
    }

    function batchMint(
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external {
        _batchMint(msg.sender, ids, values, data);
    }

    function burn(uint256 id, uint256 value) external {
        _burn(msg.sender, id, value);
    }

    function batchBurn(uint256[] calldata ids, uint256[] calldata values)
        external
    {
        _batchBurn(msg.sender, ids, values);
    }
}
</code></pre>
</div>
</div>
<div id="gasless-token-transfer" class="section level2 hasAnchor" number="7.8">
<h2><span class="header-section-number">7.8</span> 8 Gasless Token Transfer<a href="applications.html#gasless-token-transfer" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Gasless Token Transfer 是一种新兴的区块链技术，允许用户在无需支付交易手续费（gas）的情况下进行代币转移。这种机制通常通过使用代理合约或代币经济模型来实现，旨在提升用户体验并降低参与门槛。</p>
<div id="主要特点-2" class="section level3 hasAnchor" number="7.8.1">
<h3><span class="header-section-number">7.8.1</span> 主要特点<a href="applications.html#主要特点-2" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p><strong>免交易费用</strong>：用户无需直接支付 gas 费用，降低了参与区块链交易的成本，使更多用户能够轻松进入和使用区块链应用。</p></li>
<li><p><strong>用户体验优化</strong>：通过简化转账过程，用户可以在不担心 gas 费用的情况下进行频繁的代币交易，提升了应用的可用性。</p></li>
<li><p><strong>代理合约</strong>：通常，gasless 转账通过一个代理合约来实现。用户授权该合约处理他们的代币转账，合约在后台承担了手续费。</p></li>
<li><p><strong>补偿机制</strong>：一些实现可能通过补偿机制（如通过 DApp 的收入或其他方式）来支付 gas 费用，从而使用户能够享受无手续费的体验。</p></li>
</ol>
</div>
<div id="应用场景-2" class="section level3 hasAnchor" number="7.8.2">
<h3><span class="header-section-number">7.8.2</span> 应用场景<a href="applications.html#应用场景-2" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li><p><strong>去中心化金融（DeFi）</strong>：在 DeFi 应用中，用户可以更轻松地进行流动性提供、借贷等操作，而不需要担心 gas 费用的波动。</p></li>
<li><p><strong>游戏</strong>：在区块链游戏中，玩家可以频繁地进行交易而不受 gas 费用影响，从而增强游戏体验。</p></li>
<li><p><strong>NFT 市场</strong>：用户可以在 NFT 交易市场中更轻松地买卖资产，鼓励更多用户参与。</p></li>
</ul>
<p>Gasless ERC20 token transfer with Meta transaction</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC20Permit {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount)
        external
        returns (bool);
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract GaslessTokenTransfer {
    function send(
        address token,
        address sender,
        address receiver,
        uint256 amount,
        uint256 fee,
        uint256 deadline,
        // Permit signature
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // Permit
        IERC20Permit(token).permit(
            sender, address(this), amount + fee, deadline, v, r, s
        );
        // Send amount to receiver
        IERC20Permit(token).transferFrom(sender, receiver, amount);
        // Take fee - send fee to msg.sender
        IERC20Permit(token).transferFrom(sender, msg.sender, fee);
    }
}

</code></pre>
<p>Example ERC20 that implements permit copied from solmate</p>
<pre><code>// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity &gt;=0.8.0;

/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)
/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
abstract contract ERC20 {
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(
        address indexed owner, address indexed spender, uint256 amount
    );

    string public name;
    string public symbol;
    uint8 public immutable decimals;
    uint256 public totalSupply;
    mapping(address =&gt; uint256) public balanceOf;
    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;
    uint256 internal immutable INITIAL_CHAIN_ID;
    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;
    mapping(address =&gt; uint256) public nonces;

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        INITIAL_CHAIN_ID = block.chainid;
        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
    }

    function approve(address spender, uint256 amount)
        public
        virtual
        returns (bool)
    {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transfer(address to, uint256 amount)
        public
        virtual
        returns (bool)
    {
        balanceOf[msg.sender] -= amount;

        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount)
        public
        virtual
        returns (bool)
    {
        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.
        if (allowed != type(uint256).max) {
            allowance[from][msg.sender] = allowed - amount;
        }
        balanceOf[from] -= amount;

        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(from, to, amount);
        return true;
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        require(deadline &gt;= block.timestamp, &quot;PERMIT_DEADLINE_EXPIRED&quot;);

        unchecked {
            address recoveredAddress = ecrecover(
                keccak256(
                    abi.encodePacked(
                        &quot;\x19\x01&quot;,
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                keccak256(
                                    &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;
                                ),
                                owner,
                                spender,
                                value,
                                nonces[owner]++,
                                deadline
                            )
                        )
                    )
                ),
                v,
                r,
                s
            );

            require(
                recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner,
                &quot;INVALID_SIGNER&quot;
            );

            allowance[recoveredAddress][spender] = value;
        }

        emit Approval(owner, spender, value);
    }

    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
        return block.chainid == INITIAL_CHAIN_ID
            ? INITIAL_DOMAIN_SEPARATOR
            : computeDomainSeparator();
    }

    function computeDomainSeparator() internal view virtual returns (bytes32) {
        return keccak256(
            abi.encode(
                keccak256(
                    &quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;
                ),
                keccak256(bytes(name)),
                keccak256(&quot;1&quot;),
                block.chainid,
                address(this)
            )
        );
    }

    function _mint(address to, uint256 amount) internal virtual {
        totalSupply += amount;

        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal virtual {
        balanceOf[from] -= amount;

        unchecked {
            totalSupply -= amount;
        }

        emit Transfer(from, address(0), amount);
    }
}

contract ERC20Permit is ERC20 {
    constructor(string memory _name, string memory _symbol, uint8 _decimals)
        ERC20(_name, _symbol, _decimals)
    {}

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}
</code></pre>
</div>
</div>
<div id="simple-bytecode-contract" class="section level2 hasAnchor" number="7.9">
<h2><span class="header-section-number">7.9</span> 9 Simple Bytecode Contract<a href="applications.html#simple-bytecode-contract" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Simple Bytecode Contract 是一种基本的智能合约，其主要功能是展示如何通过字节码直接与以太坊网络进行交互。这种合约通常用于教育和测试目的，帮助开发者理解以太坊的底层机制。</p>
<div id="主要特点-3" class="section level3 hasAnchor" number="7.9.1">
<h3><span class="header-section-number">7.9.1</span> 主要特点<a href="applications.html#主要特点-3" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p><strong>字节码表示</strong>：合约的所有功能和状态都是通过字节码实现的，这种方式强调了智能合约在以太坊虚拟机（EVM）中的执行过程。</p></li>
<li><p><strong>简化结构</strong>：Simple Bytecode Contract 通常包含最少的功能，便于开发者理解基本的合约结构和 EVM 操作。</p></li>
<li><p><strong>可部署性</strong>：用户可以将字节码直接部署到以太坊网络中，而无需复杂的编程环境。</p></li>
<li><p><strong>低级交互</strong>：通过简单的字节码合约，开发者可以学习如何进行底层的操作，比如状态存储、调用和返回值处理。</p></li>
</ol>
</div>
<div id="应用场景-3" class="section level3 hasAnchor" number="7.9.2">
<h3><span class="header-section-number">7.9.2</span> 应用场景<a href="applications.html#应用场景-3" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li><p><strong>教育目的</strong>：作为学习智能合约开发的基础，帮助初学者了解 EVM 的工作原理和合约的基本概念。</p></li>
<li><p><strong>测试与实验</strong>：开发者可以在测试网络上部署简单字节码合约，以验证其理解和测试不同的 EVM 操作。</p></li>
<li><p><strong>性能分析</strong>：研究人员可以使用这些合约来分析和优化合约的执行效率和 gas 成本。</p></li>
</ul>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Factory {
    event Log(address addr);

    // Deploys a contract that always returns 255
    function deploy() external {
        bytes memory bytecode = hex&quot;6960ff60005260206000f3600052600a6016f3&quot;;
        address addr;
        assembly {
            // create(value, offset, size)
            addr := create(0, add(bytecode, 0x20), 0x13)
        }
        require(addr != address(0));

        emit Log(addr);
    }
}

interface IContract {
    function getValue() external view returns (uint256);
}

// https://www.evm.codes/playground
/*
Run time code - return 255
60ff60005260206000f3

// Store 255 to memory
mstore(p, v) - store v at memory p to p + 32

PUSH1 0xff
PUSH1 0
MSTORE

// Return 32 bytes from memory
return(p, s) - end execution and return data from memory p to p + s

PUSH1 0x20
PUSH1 0
RETURN

Creation code - return runtime code
6960ff60005260206000f3600052600a6016f3

// Store run time code to memory
PUSH10 0X60ff60005260206000f3
PUSH1 0
MSTORE

// Return 10 bytes from memory starting at offset 22
PUSH1 0x0a
PUSH1 0x16
RETURN
*/
</code></pre>
</div>
</div>
<div id="precompute-contract-address-with-create2" class="section level2 hasAnchor" number="7.10">
<h2><span class="header-section-number">7.10</span> 10 Precompute Contract Address with Create2<a href="applications.html#precompute-contract-address-with-create2" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Create2 是以太坊引入的一种方法，用于在部署智能合约时预计算合约地址。这种机制允许开发者在合约部署之前预测合约的地址，从而提升合约的可预测性和安全性。</p>
<div id="主要特点-4" class="section level3 hasAnchor" number="7.10.1">
<h3><span class="header-section-number">7.10.1</span> 主要特点<a href="applications.html#主要特点-4" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p><strong>可预测性</strong>：使用 Create2，开发者可以根据给定的参数（如盐值和字节码）预先计算出合约地址。这使得合约地址在部署之前是可知的，有助于其他合约或用户进行交互。</p></li>
<li><p><strong>盐值机制</strong>：Create2 允许开发者使用一个自定义的盐值（salt），这一机制增加了生成地址的多样性。不同的盐值和字节码组合将生成不同的合约地址。</p></li>
<li><p><strong>安全性增强</strong>：由于可以预先计算合约地址，开发者能够在合约交互中验证地址的正确性，从而降低了合约被错误地址攻击的风险。</p></li>
<li><p><strong>无状态合约</strong>：Create2 支持部署无状态合约，这意味着即使在合约被销毁后，其地址仍然有效，可以用于某些特定用途，如代币的逻辑分发。</p></li>
</ol>
</div>
<div id="应用场景-4" class="section level3 hasAnchor" number="7.10.2">
<h3><span class="header-section-number">7.10.2</span> 应用场景<a href="applications.html#应用场景-4" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li><p><strong>合约工厂模式</strong>：开发者可以创建合约工厂，使用 Create2 在已知地址上部署多个合约实例，从而减少部署和交互的复杂性。</p></li>
<li><p><strong>代币和 NFT</strong>：在代币或 NFT 项目中，Create2 可用于确保所有相关合约的地址在部署前都是可预测的，简化了用户交互和集成流程。</p></li>
<li><p><strong>高效的合约升级</strong>：通过预计算地址，开发者可以设计合约升级机制，使得新版本合约能够在特定地址下被部署，从而无缝替换旧版本。</p></li>
</ul>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Factory {
    // Returns the address of the newly deployed contract
    function deploy(address _owner, uint256 _foo, bytes32 _salt)
        public
        payable
        returns (address)
    {
        // This syntax is a newer way to invoke create2 without assembly, you just need to pass salt
        // https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations-create2
        return address(new TestContract{salt: _salt}(_owner, _foo));
    }
}

// This is the older way of doing it using assembly
contract FactoryAssembly {
    event Deployed(address addr, uint256 salt);

    // 1. Get bytecode of contract to be deployed
    // NOTE: _owner and _foo are arguments of the TestContract&#39;s constructor
    function getBytecode(address _owner, uint256 _foo)
        public
        pure
        returns (bytes memory)
    {
        bytes memory bytecode = type(TestContract).creationCode;

        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));
    }

    // 2. Compute the address of the contract to be deployed
    // NOTE: _salt is a random number used to create an address
    function getAddress(bytes memory bytecode, uint256 _salt)
        public
        view
        returns (address)
    {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff), address(this), _salt, keccak256(bytecode)
            )
        );

        // NOTE: cast last 20 bytes of hash to address
        return address(uint160(uint256(hash)));
    }

    // 3. Deploy the contract
    // NOTE:
    // Check the event log Deployed which contains the address of the deployed TestContract.
    // The address in the log should equal the address computed from above.
    function deploy(bytes memory bytecode, uint256 _salt) public payable {
        address addr;

        /*
        NOTE: How to call create2

        create2(v, p, n, s)
        create new contract with code at memory p to p + n
        and send v wei
        and return the new address
        where new address = first 20 bytes of keccak256(0xff + address(this) + s + keccak256(mem[p…(p+n)))
              s = big-endian 256-bit value
        */
        assembly {
            addr :=
                create2(
                    callvalue(), // wei sent with current call
                    // Actual code starts after skipping the first 32 bytes
                    add(bytecode, 0x20),
                    mload(bytecode), // Load the size of code contained in the first 32 bytes
                    _salt // Salt from function arguments
                )

            if iszero(extcodesize(addr)) { revert(0, 0) }
        }

        emit Deployed(addr, _salt);
    }
}

contract TestContract {
    address public owner;
    uint256 public foo;

    constructor(address _owner, uint256 _foo) payable {
        owner = _owner;
        foo = _foo;
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}

</code></pre>
</div>
</div>
<div id="minimal-proxy-contract" class="section level2 hasAnchor" number="7.11">
<h2><span class="header-section-number">7.11</span> 10 Minimal Proxy Contract<a href="applications.html#minimal-proxy-contract" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>最小代理合约（Minimal Proxy Contract）是一种轻量级的智能合约设计模式，主要用于节省部署成本和减少区块链上的存储需求。它通过代理合约的方式，实现对逻辑合约的调用，而不需要在每个实例中重复存储所有的逻辑。</p>
<div id="主要特点-5" class="section level3 hasAnchor" number="7.11.1">
<h3><span class="header-section-number">7.11.1</span> 主要特点<a href="applications.html#主要特点-5" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p><strong>节省 Gas 成本</strong>：最小代理合约的代码量极小，主要只包含必要的转发逻辑。这使得部署代理合约的 Gas 成本显著低于直接部署完整合约。</p></li>
<li><p><strong>灵活的逻辑更新</strong>：代理合约可以指向不同的逻辑合约，从而实现逻辑的更新和替换。这种方式允许开发者在不影响用户地址和状态的情况下，更新合约功能。</p></li>
<li><p><strong>标准化模式</strong>：根据 EIP-1167 标准，最小代理合约的实现方法得到了广泛认可，确保了合约的可互操作性。</p></li>
<li><p><strong>透明性</strong>：虽然使用代理模式，但用户仍然可以清楚地看到与其交互的逻辑合约地址，保证了透明性。</p></li>
</ol>
</div>
<div id="应用场景-5" class="section level3 hasAnchor" number="7.11.2">
<h3><span class="header-section-number">7.11.2</span> 应用场景<a href="applications.html#应用场景-5" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li><p><strong>可升级合约</strong>：在需要频繁更新合约逻辑的应用中，使用最小代理合约可以方便地管理版本更新。</p></li>
<li><p><strong>节约资源</strong>：对于需要部署大量相似合约的场景（如代币发行），最小代理合约可以显著减少部署和存储成本。</p></li>
<li><p><strong>合约工厂</strong>：可以通过工厂合约创建多个代理合约，每个合约可以指向相同的逻辑合约，便于管理和扩展。</p></li>
</ul>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

// original code
// https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol

contract MinimalProxy {
    function clone(address target) external returns (address result) {
        // convert address to 20 bytes
        bytes20 targetBytes = bytes20(target);

        // actual code //
        // 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3

        // creation code //
        // copy runtime code into memory and return it
        // 3d602d80600a3d3981f3

        // runtime code //
        // code to delegatecall to address
        // 363d3d373d3d3d363d73 address 5af43d82803e903d91602b57fd5bf3

        assembly {
            /*
            reads the 32 bytes of memory starting at pointer stored in 0x40

            In solidity, the 0x40 slot in memory is special: it contains the &quot;free memory pointer&quot;
            which points to the end of the currently allocated memory.
            */
            let clone := mload(0x40)
            // store 32 bytes to memory starting at &quot;clone&quot;
            mstore(
                clone,
                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000
            )

            /*
              |              20 bytes                |
            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000
                                                      ^
                                                      pointer
            */
            // store 32 bytes to memory starting at &quot;clone&quot; + 20 bytes
            // 0x14 = 20
            mstore(add(clone, 0x14), targetBytes)

            /*
              |               20 bytes               |                 20 bytes              |
            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe
                                                                                              ^
                                                                                              pointer
            */
            // store 32 bytes to memory starting at &quot;clone&quot; + 40 bytes
            // 0x28 = 40
            mstore(
                add(clone, 0x28),
                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000
            )

            /*
              |               20 bytes               |                 20 bytes              |           15 bytes          |
            0x3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3
            */
            // create new contract
            // send 0 Ether
            // code starts at pointer stored in &quot;clone&quot;
            // code size 0x37 (55 bytes)
            result := create(0, clone, 0x37)
        }
    }
}
</code></pre>
</div>
</div>
<div id="upgradeable-proxy" class="section level2 hasAnchor" number="7.12">
<h2><span class="header-section-number">7.12</span> 11 Upgradeable Proxy<a href="applications.html#upgradeable-proxy" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>可升级代理（Upgradeable Proxy）是一种设计模式，允许智能合约在不改变合约地址的情况下，升级其逻辑。该模式使得合约的功能可以随着时间的推移进行更新和扩展，同时保持用户的状态和交互地址不变。</p>
<div id="主要特点-6" class="section level4 hasAnchor" number="7.12.0.1">
<h4><span class="header-section-number">7.12.0.1</span> 主要特点<a href="applications.html#主要特点-6" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ol style="list-style-type: decimal">
<li><p><strong>逻辑分离</strong>：可升级代理将合约的逻辑与状态分离。逻辑合约包含功能实现，而代理合约则负责转发请求并管理状态。这种结构使得逻辑可以独立更新。</p></li>
<li><p><strong>灵活性和可维护性</strong>：通过更改代理合约中的指向逻辑合约的地址，可以轻松升级功能，而无需迁移用户数据或更改合约地址。</p></li>
<li><p><strong>透明性</strong>：虽然用户与代理合约交互，但它们可以通过代理合约清晰地了解当前逻辑合约的地址，从而保持透明性。</p></li>
<li><p><strong>标准化</strong>：根据 EIP-1967 等标准，可升级代理的实现得到了广泛认可，确保了其可互操作性和安全性。</p></li>
</ol>
</div>
<div id="应用场景-6" class="section level4 hasAnchor" number="7.12.0.2">
<h4><span class="header-section-number">7.12.0.2</span> 应用场景<a href="applications.html#应用场景-6" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><p><strong>持续开发</strong>：在需要频繁更新合约功能的项目中，例如去中心化金融（DeFi）应用，使用可升级代理可以轻松实现功能改进和修复。</p></li>
<li><p><strong>治理和管理</strong>：可以通过治理机制控制合约的升级，确保所有利益相关者的参与和透明度。</p></li>
<li><p><strong>复杂系统</strong>：在复杂的合约系统中，多个代理合约可以指向不同的逻辑合约，从而实现更高层次的可扩展性和模块化。</p></li>
</ul>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

// Transparent upgradeable proxy pattern

contract CounterV1 {
    uint256 public count;

    function inc() external {
        count += 1;
    }
}

contract CounterV2 {
    uint256 public count;

    function inc() external {
        count += 1;
    }

    function dec() external {
        count -= 1;
    }
}

contract BuggyProxy {
    address public implementation;
    address public admin;

    constructor() {
        admin = msg.sender;
    }

    function _delegate() private {
        (bool ok,) = implementation.delegatecall(msg.data);
        require(ok, &quot;delegatecall failed&quot;);
    }

    fallback() external payable {
        _delegate();
    }

    receive() external payable {
        _delegate();
    }

    function upgradeTo(address _implementation) external {
        require(msg.sender == admin, &quot;not authorized&quot;);
        implementation = _implementation;
    }
}

contract Dev {
    function selectors() external view returns (bytes4, bytes4, bytes4) {
        return (
            Proxy.admin.selector,
            Proxy.implementation.selector,
            Proxy.upgradeTo.selector
        );
    }
}

contract Proxy {
    // All functions / variables should be private, forward all calls to fallback

    // -1 for unknown preimage
    // 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
    bytes32 private constant IMPLEMENTATION_SLOT =
        bytes32(uint256(keccak256(&quot;eip1967.proxy.implementation&quot;)) - 1);
    // 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
    bytes32 private constant ADMIN_SLOT =
        bytes32(uint256(keccak256(&quot;eip1967.proxy.admin&quot;)) - 1);

    constructor() {
        _setAdmin(msg.sender);
    }

    modifier ifAdmin() {
        if (msg.sender == _getAdmin()) {
            _;
        } else {
            _fallback();
        }
    }

    function _getAdmin() private view returns (address) {
        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
    }

    function _setAdmin(address _admin) private {
        require(_admin != address(0), &quot;admin = zero address&quot;);
        StorageSlot.getAddressSlot(ADMIN_SLOT).value = _admin;
    }

    function _getImplementation() private view returns (address) {
        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
    }

    function _setImplementation(address _implementation) private {
        require(
            _implementation.code.length &gt; 0, &quot;implementation is not contract&quot;
        );
        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = _implementation;
    }

    // Admin interface //
    function changeAdmin(address _admin) external ifAdmin {
        _setAdmin(_admin);
    }

    // 0x3659cfe6
    function upgradeTo(address _implementation) external ifAdmin {
        _setImplementation(_implementation);
    }

    // 0xf851a440
    function admin() external ifAdmin returns (address) {
        return _getAdmin();
    }

    // 0x5c60da1b
    function implementation() external ifAdmin returns (address) {
        return _getImplementation();
    }

    // User interface //
    function _delegate(address _implementation) internal virtual {
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.

            // calldatacopy(t, f, s) - copy s bytes from calldata at position f to mem at position t
            // calldatasize() - size of call data in bytes
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don&#39;t know the size yet.

            // delegatecall(g, a, in, insize, out, outsize) -
            // - call contract at address a
            // - with input mem[in…(in+insize))
            // - providing g gas
            // - and output area mem[out…(out+outsize))
            // - returning 0 on error (eg. out of gas) and 1 on success
            let result :=
                delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            // returndatacopy(t, f, s) - copy s bytes from returndata at position f to mem at position t
            // returndatasize() - size of the last returndata
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                // revert(p, s) - end execution, revert state changes, return data mem[p…(p+s))
                revert(0, returndatasize())
            }
            default {
                // return(p, s) - end execution, return data mem[p…(p+s))
                return(0, returndatasize())
            }
        }
    }

    function _fallback() private {
        _delegate(_getImplementation());
    }

    fallback() external payable {
        _fallback();
    }

    receive() external payable {
        _fallback();
    }
}

contract ProxyAdmin {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, &quot;not owner&quot;);
        _;
    }

    function getProxyAdmin(address proxy) external view returns (address) {
        (bool ok, bytes memory res) =
            proxy.staticcall(abi.encodeCall(Proxy.admin, ()));
        require(ok, &quot;call failed&quot;);
        return abi.decode(res, (address));
    }

    function getProxyImplementation(address proxy)
        external
        view
        returns (address)
    {
        (bool ok, bytes memory res) =
            proxy.staticcall(abi.encodeCall(Proxy.implementation, ()));
        require(ok, &quot;call failed&quot;);
        return abi.decode(res, (address));
    }

    function changeProxyAdmin(address payable proxy, address admin)
        external
        onlyOwner
    {
        Proxy(proxy).changeAdmin(admin);
    }

    function upgrade(address payable proxy, address implementation)
        external
        onlyOwner
    {
        Proxy(proxy).upgradeTo(implementation);
    }
}

library StorageSlot {
    struct AddressSlot {
        address value;
    }

    function getAddressSlot(bytes32 slot)
        internal
        pure
        returns (AddressSlot storage r)
    {
        assembly {
            r.slot := slot
        }
    }
}

contract TestSlot {
    bytes32 public constant slot = keccak256(&quot;TEST_SLOT&quot;);

    function getSlot() external view returns (address) {
        return StorageSlot.getAddressSlot(slot).value;
    }

    function writeSlot(address _addr) external {
        StorageSlot.getAddressSlot(slot).value = _addr;
    }
}
</code></pre>
</div>
</div>
<div id="deploy-any-contract" class="section level2 hasAnchor" number="7.13">
<h2><span class="header-section-number">7.13</span> 12 Deploy Any Contract<a href="applications.html#deploy-any-contract" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<ol style="list-style-type: decimal">
<li>Deploy any contract by calling Proxy.deploy(bytes memory _code)</li>
<li>For this example, you can get the contract bytecodes by calling Helper.getBytecode1 and Helper.getBytecode2</li>
</ol>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract Proxy {
    event Deploy(address);

    receive() external payable {}

    function deploy(bytes memory _code)
        external
        payable
        returns (address addr)
    {
        assembly {
            // create(v, p, n)
            // v = amount of ETH to send
            // p = pointer in memory to start of code
            // n = size of code
            addr := create(callvalue(), add(_code, 0x20), mload(_code))
        }
        // return address 0 on error
        require(addr != address(0), &quot;deploy failed&quot;);

        emit Deploy(addr);
    }

    function execute(address _target, bytes memory _data) external payable {
        (bool success,) = _target.call{value: msg.value}(_data);
        require(success, &quot;failed&quot;);
    }
}

contract TestContract1 {
    address public owner = msg.sender;

    function setOwner(address _owner) public {
        require(msg.sender == owner, &quot;not owner&quot;);
        owner = _owner;
    }
}

contract TestContract2 {
    address public owner = msg.sender;
    uint256 public value = msg.value;
    uint256 public x;
    uint256 public y;

    constructor(uint256 _x, uint256 _y) payable {
        x = _x;
        y = _y;
    }
}

contract Helper {
    function getBytecode1() external pure returns (bytes memory) {
        bytes memory bytecode = type(TestContract1).creationCode;
        return bytecode;
    }

    function getBytecode2(uint256 _x, uint256 _y)
        external
        pure
        returns (bytes memory)
    {
        bytes memory bytecode = type(TestContract2).creationCode;
        return abi.encodePacked(bytecode, abi.encode(_x, _y));
    }

    function getCalldata(address _owner) external pure returns (bytes memory) {
        return abi.encodeWithSignature(&quot;setOwner(address)&quot;, _owner);
    }
}
</code></pre>
</div>
<div id="write-to-any-slot" class="section level2 hasAnchor" number="7.14">
<h2><span class="header-section-number">7.14</span> 13 Write to Any Slot<a href="applications.html#write-to-any-slot" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Solidity存储就像一个长度为2^256的数组。阵列中的每个插槽可以存储32个字节。</p>
<p>声明的顺序和状态变量的类型定义了它将使用哪些插槽。</p>
<p>但是，使用程序集，您可以写入任何插槽。</p>
<pre><code>
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

library StorageSlot {
    // Wrap address in a struct so that it can be passed around as a storage pointer
    struct AddressSlot {
        address value;
    }

    function getAddressSlot(bytes32 slot)
        internal
        pure
        returns (AddressSlot storage pointer)
    {
        assembly {
            // Get the pointer to AddressSlot stored at slot
            pointer.slot := slot
        }
    }
}

contract TestSlot {
    bytes32 public constant TEST_SLOT = keccak256(&quot;TEST_SLOT&quot;);

    function write(address _addr) external {
        StorageSlot.AddressSlot storage data =
            StorageSlot.getAddressSlot(TEST_SLOT);
        data.value = _addr;
    }

    function get() external view returns (address) {
        StorageSlot.AddressSlot storage data =
            StorageSlot.getAddressSlot(TEST_SLOT);
        return data.value;
    }
}
</code></pre>
</div>
<div id="单向支付渠道" class="section level2 hasAnchor" number="7.15">
<h2><span class="header-section-number">7.15</span> 14 单向支付渠道<a href="applications.html#单向支付渠道" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>支付渠道允许参与者在链下重复转移以太币。</p>
<p>以下是本合同的使用方式：</p>
<ul>
<li>Alice部署合约，用一些以太币为其提供资金。</li>
<li>Alice通过签署消息（链下）授权付款，并将签名发送给Bob。</li>
<li>Bob通过向智能合约提交签名的消息来要求付款。</li>
<li>如果Bob没有要求付款，Alice将在合同到期后取回她的以太币</li>
</ul>
<p>这被称为单向支付渠道，因为支付只能从Alice到Bob单向进行。</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import &quot;./ECDSA.sol&quot;;

contract ReentrancyGuard {
    bool private locked;

    modifier guard() {
        require(!locked);
        locked = true;
        _;
        locked = false;
    }
}

contract UniDirectionalPaymentChannel is ReentrancyGuard {
    using ECDSA for bytes32;

    address payable public sender;
    address payable public receiver;

    uint256 private constant DURATION = 7 * 24 * 60 * 60;
    uint256 public expiresAt;

    constructor(address payable _receiver) payable {
        require(_receiver != address(0), &quot;receiver = zero address&quot;);
        sender = payable(msg.sender);
        receiver = _receiver;
        expiresAt = block.timestamp + DURATION;
    }

    function _getHash(uint256 _amount) private view returns (bytes32) {
        // NOTE: sign with address of this contract to protect agains
        // replay attack on other contracts
        return keccak256(abi.encodePacked(address(this), _amount));
    }

    function getHash(uint256 _amount) external view returns (bytes32) {
        return _getHash(_amount);
    }

    function _getEthSignedHash(uint256 _amount)
        private
        view
        returns (bytes32)
    {
        return _getHash(_amount).toEthSignedMessageHash();
    }

    function getEthSignedHash(uint256 _amount)
        external
        view
        returns (bytes32)
    {
        return _getEthSignedHash(_amount);
    }

    function _verify(uint256 _amount, bytes memory _sig)
        private
        view
        returns (bool)
    {
        return _getEthSignedHash(_amount).recover(_sig) == sender;
    }

    function verify(uint256 _amount, bytes memory _sig)
        external
        view
        returns (bool)
    {
        return _verify(_amount, _sig);
    }

    function close(uint256 _amount, bytes memory _sig) external guard {
        require(msg.sender == receiver, &quot;!receiver&quot;);
        require(_verify(_amount, _sig), &quot;invalid sig&quot;);

        (bool sent,) = receiver.call{value: _amount}(&quot;&quot;);
        require(sent, &quot;Failed to send Ether&quot;);
        selfdestruct(sender);
    }

    function cancel() external {
        require(msg.sender == sender, &quot;!sender&quot;);
        require(block.timestamp &gt;= expiresAt, &quot;!expired&quot;);
        selfdestruct(sender);
    }
}

</code></pre>
</div>
<div id="bi-directional-payment-channel" class="section level2 hasAnchor" number="7.16">
<h2><span class="header-section-number">7.16</span> 15 Bi-Directional Payment Channel<a href="applications.html#bi-directional-payment-channel" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>双向支付渠道允许参与者Alice和Bob在链下重复转移以太币。</p>
<p>付款可以双向进行，Alice支付Bob，Bob支付Alice。</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import &quot;./ECDSA.sol&quot;;

/*
Opening a channel
1. Alice and Bob fund a multi-sig wallet
2. Precompute payment channel address
3. Alice and Bob exchanges signatures of initial balances
4. Alice and Bob creates a transaction that can deploy a payment channel from
   the multi-sig wallet

Update channel balances
1. Repeat steps 1 - 3 from opening a channel
2. From multi-sig wallet create a transaction that will
   - delete the transaction that would have deployed the old payment channel
   - and then create a transaction that can deploy a payment channel with the
     new balances

Closing a channel when Alice and Bob agree on the final balance
1. From multi-sig wallet create a transaction that will
   - send payments to Alice and Bob
   - and then delete the transaction that would have created the payment channel

Closing a channel when Alice and Bob do not agree on the final balances
1. Deploy payment channel from multi-sig
2. call challengeExit() to start the process of closing a channel
3. Alice and Bob can withdraw funds once the channel is expired
*/

contract BiDirectionalPaymentChannel {
    using ECDSA for bytes32;

    event ChallengeExit(address indexed sender, uint256 nonce);
    event Withdraw(address indexed to, uint256 amount);

    address payable[2] public users;
    mapping(address =&gt; bool) public isUser;

    mapping(address =&gt; uint256) public balances;

    uint256 public challengePeriod;
    uint256 public expiresAt;
    uint256 public nonce;

    modifier checkBalances(uint256[2] memory _balances) {
        require(
            address(this).balance &gt;= _balances[0] + _balances[1],
            &quot;balance of contract must be &gt;= to the total balance of users&quot;
        );
        _;
    }

    // NOTE: deposit from multi-sig wallet
    constructor(
        address payable[2] memory _users,
        uint256[2] memory _balances,
        uint256 _expiresAt,
        uint256 _challengePeriod
    ) payable checkBalances(_balances) {
        require(_expiresAt &gt; block.timestamp, &quot;Expiration must be &gt; now&quot;);
        require(_challengePeriod &gt; 0, &quot;Challenge period must be &gt; 0&quot;);

        for (uint256 i = 0; i &lt; _users.length; i++) {
            address payable user = _users[i];

            require(!isUser[user], &quot;user must be unique&quot;);
            users[i] = user;
            isUser[user] = true;

            balances[user] = _balances[i];
        }

        expiresAt = _expiresAt;
        challengePeriod = _challengePeriod;
    }

    function verify(
        bytes[2] memory _signatures,
        address _contract,
        address[2] memory _signers,
        uint256[2] memory _balances,
        uint256 _nonce
    ) public pure returns (bool) {
        for (uint256 i = 0; i &lt; _signatures.length; i++) {
            /*
            NOTE: sign with address of this contract to protect
                  agains replay attack on other contracts
            */
            bool valid = _signers[i]
                == keccak256(abi.encodePacked(_contract, _balances, _nonce))
                    .toEthSignedMessageHash().recover(_signatures[i]);

            if (!valid) {
                return false;
            }
        }

        return true;
    }

    modifier checkSignatures(
        bytes[2] memory _signatures,
        uint256[2] memory _balances,
        uint256 _nonce
    ) {
        // Note: copy storage array to memory
        address[2] memory signers;
        for (uint256 i = 0; i &lt; users.length; i++) {
            signers[i] = users[i];
        }

        require(
            verify(_signatures, address(this), signers, _balances, _nonce),
            &quot;Invalid signature&quot;
        );

        _;
    }

    modifier onlyUser() {
        require(isUser[msg.sender], &quot;Not user&quot;);
        _;
    }

    function challengeExit(
        uint256[2] memory _balances,
        uint256 _nonce,
        bytes[2] memory _signatures
    )
        public
        onlyUser
        checkSignatures(_signatures, _balances, _nonce)
        checkBalances(_balances)
    {
        require(block.timestamp &lt; expiresAt, &quot;Expired challenge period&quot;);
        require(_nonce &gt; nonce, &quot;Nonce must be greater than the current nonce&quot;);

        for (uint256 i = 0; i &lt; _balances.length; i++) {
            balances[users[i]] = _balances[i];
        }

        nonce = _nonce;
        expiresAt = block.timestamp + challengePeriod;

        emit ChallengeExit(msg.sender, nonce);
    }

    function withdraw() public onlyUser {
        require(
            block.timestamp &gt;= expiresAt, &quot;Challenge period has not expired yet&quot;
        );

        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;

        (bool sent,) = msg.sender.call{value: amount}(&quot;&quot;);
        require(sent, &quot;Failed to send Ether&quot;);

        emit Withdraw(msg.sender, amount);
    }
}
</code></pre>
</div>
<div id="英式拍卖" class="section level2 hasAnchor" number="7.17">
<h2><span class="header-section-number">7.17</span> 16 英式拍卖<a href="applications.html#英式拍卖" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>拍卖流程</p>
<ol style="list-style-type: decimal">
<li>NFT的卖家部署该合约。<br />
</li>
<li>拍卖持续7天。<br />
</li>
<li>参与者可以通过存入高于当前最高出价者的ETH进行出价。<br />
</li>
<li>所有出价者如果不是当前最高出价，可以撤回他们的出价。</li>
</ol>
<p>拍卖结束后</p>
<ol style="list-style-type: decimal">
<li>最高出价者成为NFT的新拥有者。<br />
</li>
<li>卖家收到最高出价的ETH。</li>
</ol>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId)
        external;
    function transferFrom(address, address, uint256) external;
}

contract EnglishAuction {
    event Start();
    event Bid(address indexed sender, uint256 amount);
    event Withdraw(address indexed bidder, uint256 amount);
    event End(address winner, uint256 amount);

    IERC721 public nft;
    uint256 public nftId;

    address payable public seller;
    uint256 public endAt;
    bool public started;
    bool public ended;

    address public highestBidder;
    uint256 public highestBid;
    mapping(address =&gt; uint256) public bids;

    constructor(address _nft, uint256 _nftId, uint256 _startingBid) {
        nft = IERC721(_nft);
        nftId = _nftId;

        seller = payable(msg.sender);
        highestBid = _startingBid;
    }

    function start() external {
        require(!started, &quot;started&quot;);
        require(msg.sender == seller, &quot;not seller&quot;);

        nft.transferFrom(msg.sender, address(this), nftId);
        started = true;
        endAt = block.timestamp + 7 days;

        emit Start();
    }

    function bid() external payable {
        require(started, &quot;not started&quot;);
        require(block.timestamp &lt; endAt, &quot;ended&quot;);
        require(msg.value &gt; highestBid, &quot;value &lt; highest&quot;);

        if (highestBidder != address(0)) {
            bids[highestBidder] += highestBid;
        }

        highestBidder = msg.sender;
        highestBid = msg.value;

        emit Bid(msg.sender, msg.value);
    }

    function withdraw() external {
        uint256 bal = bids[msg.sender];
        bids[msg.sender] = 0;
        payable(msg.sender).transfer(bal);

        emit Withdraw(msg.sender, bal);
    }

    function end() external {
        require(started, &quot;not started&quot;);
        require(block.timestamp &gt;= endAt, &quot;not ended&quot;);
        require(!ended, &quot;ended&quot;);

        ended = true;
        if (highestBidder != address(0)) {
            nft.safeTransferFrom(address(this), highestBidder, nftId);
            seller.transfer(highestBid);
        } else {
            nft.safeTransferFrom(address(this), seller, nftId);
        }

        emit End(highestBidder, highestBid);
    }
}
</code></pre>
</div>
<div id="荷兰式拍卖" class="section level2 hasAnchor" number="7.18">
<h2><span class="header-section-number">7.18</span> 17 荷兰式拍卖<a href="applications.html#荷兰式拍卖" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>拍卖流程</p>
<ol style="list-style-type: decimal">
<li>NFT的卖家部署该合约，并设定NFT的起始价格。<br />
</li>
<li>拍卖持续7天。<br />
</li>
<li>NFT的价格随时间降低。<br />
</li>
<li>参与者可以通过存入高于智能合约计算的当前价格的ETH进行购买。</li>
</ol>
<p>拍卖结束</p>
<p>当有买家购买NFT时，拍卖结束。</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC721 {
    function transferFrom(address _from, address _to, uint256 _nftId)
        external;
}

contract DutchAuction {
    uint256 private constant DURATION = 7 days;

    IERC721 public immutable nft;
    uint256 public immutable nftId;

    address payable public immutable seller;
    uint256 public immutable startingPrice;
    uint256 public immutable startAt;
    uint256 public immutable expiresAt;
    uint256 public immutable discountRate;

    constructor(
        uint256 _startingPrice,
        uint256 _discountRate,
        address _nft,
        uint256 _nftId
    ) {
        seller = payable(msg.sender);
        startingPrice = _startingPrice;
        startAt = block.timestamp;
        expiresAt = block.timestamp + DURATION;
        discountRate = _discountRate;

        require(
            _startingPrice &gt;= _discountRate * DURATION, &quot;starting price &lt; min&quot;
        );

        nft = IERC721(_nft);
        nftId = _nftId;
    }

    function getPrice() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - startAt;
        uint256 discount = discountRate * timeElapsed;
        return startingPrice - discount;
    }

    function buy() external payable {
        require(block.timestamp &lt; expiresAt, &quot;auction expired&quot;);

        uint256 price = getPrice();
        require(msg.value &gt;= price, &quot;ETH &lt; price&quot;);

        nft.transferFrom(seller, msg.sender, nftId);
        uint256 refund = msg.value - price;
        if (refund &gt; 0) {
            payable(msg.sender).transfer(refund);
        }
        selfdestruct(seller);
    }
}

</code></pre>
</div>
<div id="众筹erc20代币" class="section level2 hasAnchor" number="7.19">
<h2><span class="header-section-number">7.19</span> 18 众筹ERC20代币<a href="applications.html#众筹erc20代币" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>众筹流程</p>
<ol style="list-style-type: decimal">
<li>用户创建一个众筹活动。<br />
</li>
<li>用户可以进行承诺，将他们的代币转移到活动中。<br />
</li>
<li>当活动结束后，如果承诺的总金额超过活动目标，活动创建者可以领取资金。<br />
</li>
<li>否则，若活动未达到目标，用户可以撤回他们的承诺。</li>
</ol>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

interface IERC20 {
    function transfer(address, uint256) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract CrowdFund {
    event Launch(
        uint256 id,
        address indexed creator,
        uint256 goal,
        uint32 startAt,
        uint32 endAt
    );
    event Cancel(uint256 id);
    event Pledge(uint256 indexed id, address indexed caller, uint256 amount);
    event Unpledge(uint256 indexed id, address indexed caller, uint256 amount);
    event Claim(uint256 id);
    event Refund(uint256 id, address indexed caller, uint256 amount);

    struct Campaign {
        // Creator of campaign
        address creator;
        // Amount of tokens to raise
        uint256 goal;
        // Total amount pledged
        uint256 pledged;
        // Timestamp of start of campaign
        uint32 startAt;
        // Timestamp of end of campaign
        uint32 endAt;
        // True if goal was reached and creator has claimed the tokens.
        bool claimed;
    }

    IERC20 public immutable token;
    // Total count of campaigns created.
    // It is also used to generate id for new campaigns.
    uint256 public count;
    // Mapping from id to Campaign
    mapping(uint256 =&gt; Campaign) public campaigns;
    // Mapping from campaign id =&gt; pledger =&gt; amount pledged
    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public pledgedAmount;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function launch(uint256 _goal, uint32 _startAt, uint32 _endAt) external {
        require(_startAt &gt;= block.timestamp, &quot;start at &lt; now&quot;);
        require(_endAt &gt;= _startAt, &quot;end at &lt; start at&quot;);
        require(_endAt &lt;= block.timestamp + 90 days, &quot;end at &gt; max duration&quot;);

        count += 1;
        campaigns[count] = Campaign({
            creator: msg.sender,
            goal: _goal,
            pledged: 0,
            startAt: _startAt,
            endAt: _endAt,
            claimed: false
        });

        emit Launch(count, msg.sender, _goal, _startAt, _endAt);
    }

    function cancel(uint256 _id) external {
        Campaign memory campaign = campaigns[_id];
        require(campaign.creator == msg.sender, &quot;not creator&quot;);
        require(block.timestamp &lt; campaign.startAt, &quot;started&quot;);

        delete campaigns[_id];
        emit Cancel(_id);
    }

    function pledge(uint256 _id, uint256 _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(block.timestamp &gt;= campaign.startAt, &quot;not started&quot;);
        require(block.timestamp &lt;= campaign.endAt, &quot;ended&quot;);

        campaign.pledged += _amount;
        pledgedAmount[_id][msg.sender] += _amount;
        token.transferFrom(msg.sender, address(this), _amount);

        emit Pledge(_id, msg.sender, _amount);
    }

    function unpledge(uint256 _id, uint256 _amount) external {
        Campaign storage campaign = campaigns[_id];
        require(block.timestamp &lt;= campaign.endAt, &quot;ended&quot;);

        campaign.pledged -= _amount;
        pledgedAmount[_id][msg.sender] -= _amount;
        token.transfer(msg.sender, _amount);

        emit Unpledge(_id, msg.sender, _amount);
    }

    function claim(uint256 _id) external {
        Campaign storage campaign = campaigns[_id];
        require(campaign.creator == msg.sender, &quot;not creator&quot;);
        require(block.timestamp &gt; campaign.endAt, &quot;not ended&quot;);
        require(campaign.pledged &gt;= campaign.goal, &quot;pledged &lt; goal&quot;);
        require(!campaign.claimed, &quot;claimed&quot;);

        campaign.claimed = true;
        token.transfer(campaign.creator, campaign.pledged);

        emit Claim(_id);
    }

    function refund(uint256 _id) external {
        Campaign memory campaign = campaigns[_id];
        require(block.timestamp &gt; campaign.endAt, &quot;not ended&quot;);
        require(campaign.pledged &lt; campaign.goal, &quot;pledged &gt;= goal&quot;);

        uint256 bal = pledgedAmount[_id][msg.sender];
        pledgedAmount[_id][msg.sender] = 0;
        token.transfer(msg.sender, bal);

        emit Refund(_id, msg.sender, bal);
    }
}

</code></pre>
</div>
<div id="multi-call" class="section level2 hasAnchor" number="7.20">
<h2><span class="header-section-number">7.20</span> 19 Multi Call<a href="applications.html#multi-call" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>使用 for 循环和 staticcall 聚合多个查询。以下是一个简单的合约示例，展示如何从多个合约中查询数据</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MultiCall {
    function multiCall(address[] calldata targets, bytes[] calldata data)
        external
        view
        returns (bytes[] memory)
    {
        require(targets.length == data.length, &quot;target length != data length&quot;);

        bytes[] memory results = new bytes[](data.length);

        for (uint256 i; i &lt; targets.length; i++) {
            (bool success, bytes memory result) = targets[i].staticcall(data[i]);
            require(success, &quot;call failed&quot;);
            results[i] = result;
        }

        return results;
    }
}
</code></pre>
<p>Contract to test MultiCall</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract TestMultiCall {
    function test(uint256 _i) external pure returns (uint256) {
        return _i;
    }

    function getData(uint256 _i) external pure returns (bytes memory) {
        return abi.encodeWithSelector(this.test.selector, _i);
    }
}
</code></pre>
</div>
<div id="multi-delegatecall" class="section level2 hasAnchor" number="7.21">
<h2><span class="header-section-number">7.21</span> 20 Multi Delegatecall<a href="applications.html#multi-delegatecall" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>这段代码展示了如何使用 <code>delegatecall</code> 实现多函数调用的智能合约示例。</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract MultiDelegatecall {
    error DelegatecallFailed();

    function multiDelegatecall(bytes[] memory data)
        external
        payable
        returns (bytes[] memory results)
    {
        results = new bytes[](data.length);

        for (uint256 i; i &lt; data.length; i++) {
            (bool ok, bytes memory res) = address(this).delegatecall(data[i]);
            if (!ok) {
                revert DelegatecallFailed();
            }
            results[i] = res;
        }
    }
}

// Why use multi delegatecall? Why not multi call?
// alice -&gt; multi call --- call ---&gt; test (msg.sender = multi call)
// alice -&gt; test --- delegatecall ---&gt; test (msg.sender = alice)
contract TestMultiDelegatecall is MultiDelegatecall {
    event Log(address caller, string func, uint256 i);

    function func1(uint256 x, uint256 y) external {
        // msg.sender = alice
        emit Log(msg.sender, &quot;func1&quot;, x + y);
    }

    function func2() external returns (uint256) {
        // msg.sender = alice
        emit Log(msg.sender, &quot;func2&quot;, 2);
        return 111;
    }

    mapping(address =&gt; uint256) public balanceOf;

    // WARNING: unsafe code when used in combination with multi-delegatecall
    // user can mint multiple times for the price of msg.value
    function mint() external payable {
        balanceOf[msg.sender] += msg.value;
    }
}

contract Helper {
    function getFunc1Data(uint256 x, uint256 y)
        external
        pure
        returns (bytes memory)
    {
        return
            abi.encodeWithSelector(TestMultiDelegatecall.func1.selector, x, y);
    }

    function getFunc2Data() external pure returns (bytes memory) {
        return abi.encodeWithSelector(TestMultiDelegatecall.func2.selector);
    }

    function getMintData() external pure returns (bytes memory) {
        return abi.encodeWithSelector(TestMultiDelegatecall.mint.selector);
    }
}

</code></pre>
<div id="合约解释" class="section level3 hasAnchor" number="7.21.1">
<h3><span class="header-section-number">7.21.1</span> 合约解释<a href="applications.html#合约解释" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="multidelegatecall" class="section level4 hasAnchor" number="7.21.1.1">
<h4><span class="header-section-number">7.21.1.1</span> <code>MultiDelegatecall</code><a href="applications.html#multidelegatecall" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><strong>功能</strong>：这个合约允许用户通过单个交易调用多个函数。</li>
<li><strong><code>multiDelegatecall</code></strong>：接受一个字节数组 <code>data</code>，其中每个元素是调用不同函数的编码数据。它循环遍历这些数据，使用 <code>delegatecall</code> 调用自身的函数。</li>
<li><strong><code>delegatecall</code></strong>：在调用时，<code>msg.sender</code> 保持为调用合约的地址，这意味着调用的函数能够以调用者的上下文（如状态变量等）执行。</li>
</ul>
</div>
<div id="testmultidelegatecall" class="section level4 hasAnchor" number="7.21.1.2">
<h4><span class="header-section-number">7.21.1.2</span> <code>TestMultiDelegatecall</code><a href="applications.html#testmultidelegatecall" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>继承自 <code>MultiDelegatecall</code>，包含具体的函数实现。</li>
<li><strong><code>func1</code></strong>：接受两个参数，计算并记录它们的和，发出事件日志，记录调用者的地址。</li>
<li><strong><code>func2</code></strong>：发出事件日志，并返回一个固定值。</li>
<li><strong><code>mint</code></strong>：允许用户根据发送的以太币数量增加他们的余额。这里存在安全隐患，用户可以通过多次调用来铸造多次代币，代价仅为一次的 <code>msg.value</code>。</li>
</ul>
</div>
<div id="helper" class="section level4 hasAnchor" number="7.21.1.3">
<h4><span class="header-section-number">7.21.1.3</span> <code>Helper</code><a href="applications.html#helper" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>该合约用于生成调用 <code>TestMultiDelegatecall</code> 中函数的编码数据。</li>
<li><strong><code>getFunc1Data</code></strong>、<strong><code>getFunc2Data</code></strong>、<strong><code>getMintData</code></strong>：这些函数返回对应函数调用的数据编码，以便用户在 <code>multiDelegatecall</code> 中使用。</li>
</ul>
</div>
</div>
<div id="使用场景" class="section level3 hasAnchor" number="7.21.2">
<h3><span class="header-section-number">7.21.2</span> 使用场景<a href="applications.html#使用场景" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li><strong>为什么使用 <code>delegatecall</code> 而不是普通调用</strong>：普通调用 (<code>call</code>) 会将 <code>msg.sender</code> 设置为调用合约的地址，这可能导致状态变量的访问和上下文问题。而 <code>delegatecall</code> 使得调用函数能够在调用者的上下文中执行，适合需要改变调用者状态的场景。</li>
</ul>
</div>
<div id="注意事项-1" class="section level3 hasAnchor" number="7.21.3">
<h3><span class="header-section-number">7.21.3</span> 注意事项<a href="applications.html#注意事项-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li>使用 <code>delegatecall</code> 时要小心，因为不安全的实现可能导致重入攻击或意外的状态变化。在 <code>mint</code> 函数中，若不加以控制，用户可能会利用多次调用铸造多次代币，导致不公平的结果。</li>
</ul>
</div>
</div>
<div id="时间锁-time-lock" class="section level2 hasAnchor" number="7.22">
<h2><span class="header-section-number">7.22</span> 21 时间锁 Time Lock<a href="applications.html#时间锁-time-lock" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;</p>
<p>contract TimeLock {
error NotOwnerError();
error AlreadyQueuedError(bytes32 txId);
error TimestampNotInRangeError(uint256 blockTimestamp, uint256 timestamp);
error NotQueuedError(bytes32 txId);
error TimestampNotPassedError(uint256 blockTimestmap, uint256 timestamp);
error TimestampExpiredError(uint256 blockTimestamp, uint256 expiresAt);
error TxFailedError();</p>
<pre><code>event Queue(
    bytes32 indexed txId,
    address indexed target,
    uint256 value,
    string func,
    bytes data,
    uint256 timestamp
);
event Execute(
    bytes32 indexed txId,
    address indexed target,
    uint256 value,
    string func,
    bytes data,
    uint256 timestamp
);
event Cancel(bytes32 indexed txId);

uint256 public constant MIN_DELAY = 10; // seconds
uint256 public constant MAX_DELAY = 1000; // seconds
uint256 public constant GRACE_PERIOD = 1000; // seconds

address public owner;
// tx id =&gt; queued
mapping(bytes32 =&gt; bool) public queued;

constructor() {
    owner = msg.sender;
}

modifier onlyOwner() {
    if (msg.sender != owner) {
        revert NotOwnerError();
    }
    _;
}

receive() external payable {}

function getTxId(
    address _target,
    uint256 _value,
    string calldata _func,
    bytes calldata _data,
    uint256 _timestamp
) public pure returns (bytes32) {
    return keccak256(abi.encode(_target, _value, _func, _data, _timestamp));
}

/**
 * @param _target Address of contract or account to call
 * @param _value Amount of ETH to send
 * @param _func Function signature, for example &quot;foo(address,uint256)&quot;
 * @param _data ABI encoded data send.
 * @param _timestamp Timestamp after which the transaction can be executed.
 */
function queue(
    address _target,
    uint256 _value,
    string calldata _func,
    bytes calldata _data,
    uint256 _timestamp
) external onlyOwner returns (bytes32 txId) {
    txId = getTxId(_target, _value, _func, _data, _timestamp);
    if (queued[txId]) {
        revert AlreadyQueuedError(txId);
    }
    // ---|------------|---------------|-------
    //  block    block + min     block + max
    if (
        _timestamp &lt; block.timestamp + MIN_DELAY
            || _timestamp &gt; block.timestamp + MAX_DELAY
    ) {
        revert TimestampNotInRangeError(block.timestamp, _timestamp);
    }

    queued[txId] = true;

    emit Queue(txId, _target, _value, _func, _data, _timestamp);
}

function execute(
    address _target,
    uint256 _value,
    string calldata _func,
    bytes calldata _data,
    uint256 _timestamp
) external payable onlyOwner returns (bytes memory) {
    bytes32 txId = getTxId(_target, _value, _func, _data, _timestamp);
    if (!queued[txId]) {
        revert NotQueuedError(txId);
    }
    // ----|-------------------|-------
    //  timestamp    timestamp + grace period
    if (block.timestamp &lt; _timestamp) {
        revert TimestampNotPassedError(block.timestamp, _timestamp);
    }
    if (block.timestamp &gt; _timestamp + GRACE_PERIOD) {
        revert TimestampExpiredError(
            block.timestamp, _timestamp + GRACE_PERIOD
        );
    }

    queued[txId] = false;

    // prepare data
    bytes memory data;
    if (bytes(_func).length &gt; 0) {
        // data = func selector + _data
        data = abi.encodePacked(bytes4(keccak256(bytes(_func))), _data);
    } else {
        // call fallback with data
        data = _data;
    }

    // call target
    (bool ok, bytes memory res) = _target.call{value: _value}(data);
    if (!ok) {
        revert TxFailedError();
    }

    emit Execute(txId, _target, _value, _func, _data, _timestamp);

    return res;
}

function cancel(bytes32 _txId) external onlyOwner {
    if (!queued[_txId]) {
        revert NotQueuedError(_txId);
    }

    queued[_txId] = false;

    emit Cancel(_txId);
}</code></pre>
<p>}</p>
<p>这段代码实现了一个时间锁合约 (<code>TimeLock</code>)，用于在未来的某个时间点执行某个交易，常见于去中心化自治组织（DAO）中。</p>
<div id="合约结构与功能" class="section level3 hasAnchor" number="7.22.1">
<h3><span class="header-section-number">7.22.1</span> 合约结构与功能<a href="applications.html#合约结构与功能" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="错误处理" class="section level4 hasAnchor" number="7.22.1.1">
<h4><span class="header-section-number">7.22.1.1</span> 错误处理<a href="applications.html#错误处理" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>合约中定义了一系列错误，以便在执行过程中能够清晰地识别不同的问题：
- <strong>NotOwnerError</strong>：只有合约拥有者可以执行某些操作。
- <strong>AlreadyQueuedError</strong>：交易已被排队。
- <strong>TimestampNotInRangeError</strong>：时间戳不在允许的范围内。
- <strong>NotQueuedError</strong>：交易未被排队。
- <strong>TimestampNotPassedError</strong>：时间戳尚未到达。
- <strong>TimestampExpiredError</strong>：时间戳已过期。
- <strong>TxFailedError</strong>：交易执行失败。</p>
</div>
<div id="事件" class="section level4 hasAnchor" number="7.22.1.2">
<h4><span class="header-section-number">7.22.1.2</span> 事件<a href="applications.html#事件" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>合约中定义了三个事件，用于记录交易的状态：
- <strong>Queue</strong>：交易被排队。
- <strong>Execute</strong>：交易被执行。
- <strong>Cancel</strong>：交易被取消。</p>
</div>
<div id="常量-1" class="section level4 hasAnchor" number="7.22.1.3">
<h4><span class="header-section-number">7.22.1.3</span> 常量<a href="applications.html#常量-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><strong>MIN_DELAY</strong>：最小延迟（10秒）。</li>
<li><strong>MAX_DELAY</strong>：最大延迟（1000秒）。</li>
<li><strong>GRACE_PERIOD</strong>：宽限期（1000秒）。</li>
</ul>
</div>
<div id="状态变量" class="section level4 hasAnchor" number="7.22.1.4">
<h4><span class="header-section-number">7.22.1.4</span> 状态变量<a href="applications.html#状态变量" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><strong>owner</strong>：合约的拥有者。</li>
<li><strong>queued</strong>：一个映射，记录每个交易 ID 是否已被排队。</li>
</ul>
</div>
<div id="构造函数-1" class="section level4 hasAnchor" number="7.22.1.5">
<h4><span class="header-section-number">7.22.1.5</span> 构造函数<a href="applications.html#构造函数-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>在合约创建时，合约拥有者被设定为调用合约的地址。</p>
</div>
</div>
<div id="主要功能" class="section level3 hasAnchor" number="7.22.2">
<h3><span class="header-section-number">7.22.2</span> 主要功能<a href="applications.html#主要功能" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><p><strong><code>getTxId</code></strong>：生成唯一的交易 ID，基于目标地址、发送的以太币数量、函数签名、数据和时间戳。</p></li>
<li><p><strong><code>queue</code></strong>：</p>
<ul>
<li>接受目标地址、发送的以太币数量、函数名、数据和执行时间戳。</li>
<li>检查交易 ID 是否已经排队，时间戳是否在允许的范围内。</li>
<li>将交易 ID 标记为已排队，并触发 <code>Queue</code> 事件。</li>
</ul></li>
<li><p><strong><code>execute</code></strong>：</p>
<ul>
<li>执行排队的交易。</li>
<li>检查交易是否已排队，时间戳是否已到达且未过期。</li>
<li>准备调用的数据，如果有函数名，构建函数选择器和数据。</li>
<li>使用低级 <code>call</code> 方法调用目标合约，转账以太币。</li>
<li>如果交易成功，触发 <code>Execute</code> 事件。</li>
</ul></li>
<li><p><strong><code>cancel</code></strong>：</p>
<ul>
<li>允许合约拥有者取消已排队的交易，并触发 <code>Cancel</code> 事件。</li>
</ul></li>
</ol>
</div>
<div id="使用场景-1" class="section level3 hasAnchor" number="7.22.3">
<h3><span class="header-section-number">7.22.3</span> 使用场景<a href="applications.html#使用场景-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>时间锁合约通常用于需要推迟交易执行的场景，增加透明度和安全性。通过要求在一定的延迟后才能执行交易，给与社区成员足够的时间进行审查和响应。这在 DAO 和其他去中心化应用中特别有用，以防止恶意操作或错误的操作。</p>
</div>
</div>
<div id="assembly-binary-exponentiation" class="section level2 hasAnchor" number="7.23">
<h2><span class="header-section-number">7.23</span> 22 Assembly Binary Exponentiation<a href="applications.html#assembly-binary-exponentiation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract AssemblyBinExp {
    // Binary exponentiation to calculate x**n
    function rpow(uint256 x, uint256 n, uint256 b)
        public
        pure
        returns (uint256 z)
    {
        assembly {
            switch x
            // x = 0
            case 0 {
                switch n
                // n = 0 --&gt; x**n = 0**0 --&gt; 1
                case 0 { z := b }
                // n &gt; 0 --&gt; x**n = 0**n --&gt; 0
                default { z := 0 }
            }
            default {
                switch mod(n, 2)
                // x &gt; 0 and n is even --&gt; z = 1
                case 0 { z := b }
                // x &gt; 0 and n is odd --&gt; z = x
                default { z := x }

                let half := div(b, 2) // for rounding.
                // n = n / 2, while n &gt; 0, n = n / 2
                for { n := div(n, 2) } n { n := div(n, 2) } {
                    let xx := mul(x, x)
                    // Check overflow - revert if xx / x != x
                    if iszero(eq(div(xx, x), x)) { revert(0, 0) }
                    // Round (xx + half) / b
                    let xxRound := add(xx, half)
                    // Check overflow - revert if xxRound &lt; xx
                    if lt(xxRound, xx) { revert(0, 0) }
                    x := div(xxRound, b)
                    // if n % 2 == 1
                    if mod(n, 2) {
                        let zx := mul(z, x)
                        // revert if x != 0 and zx / x != z
                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {
                            revert(0, 0)
                        }
                        // Round (zx + half) / b
                        let zxRound := add(zx, half)
                        // Check overflow - revert if zxRound &lt; zx
                        if lt(zxRound, zx) { revert(0, 0) }
                        z := div(zxRound, b)
                    }
                }
            }
        }
    }
}
</code></pre>
<p>这段代码展示了如何在 Solidity 中使用汇编语言实现二进制指数运算（Binary Exponentiation）。该方法可以有效地计算 <span class="math inline">\(x^n\)</span>，并在计算过程中考虑了溢出和舍入的情况。</p>
<div id="合约结构" class="section level3 hasAnchor" number="7.23.1">
<h3><span class="header-section-number">7.23.1</span> 合约结构<a href="applications.html#合约结构" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="合约名称" class="section level4 hasAnchor" number="7.23.1.1">
<h4><span class="header-section-number">7.23.1.1</span> 合约名称<a href="applications.html#合约名称" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><code>AssemblyBinExp</code></p>
</div>
<div id="函数-rpow" class="section level4 hasAnchor" number="7.23.1.2">
<h4><span class="header-section-number">7.23.1.2</span> 函数 <code>rpow</code><a href="applications.html#函数-rpow" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><strong>参数</strong>：
<ul>
<li><code>uint256 x</code>：底数。</li>
<li><code>uint256 n</code>：指数。</li>
<li><code>uint256 b</code>：舍入基数，用于避免整数除法时的精度丢失。</li>
</ul></li>
<li><strong>返回</strong>：
<ul>
<li><code>uint256 z</code>：计算结果。</li>
</ul></li>
</ul>
</div>
</div>
<div id="汇编代码解析" class="section level3 hasAnchor" number="7.23.2">
<h3><span class="header-section-number">7.23.2</span> 汇编代码解析<a href="applications.html#汇编代码解析" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ol style="list-style-type: decimal">
<li><strong>处理特殊情况</strong>：
<ul>
<li>当 <span class="math inline">\(x = 0\)</span> 时：
<ul>
<li>如果 <span class="math inline">\(n = 0\)</span>，返回 <span class="math inline">\(1\)</span>（0 的 0 次方定义为 1）。</li>
<li>如果 <span class="math inline">\(n &gt; 0\)</span>，返回 <span class="math inline">\(0\)</span>（任何数的 0 次方是 0）。</li>
</ul></li>
</ul></li>
<li><strong>一般情况</strong>：
<ul>
<li>当 <span class="math inline">\(x &gt; 0\)</span> 时，根据 <span class="math inline">\(n\)</span> 的奇偶性初始化 <span class="math inline">\(z\)</span>：
<ul>
<li>如果 <span class="math inline">\(n\)</span> 是偶数，初始化 <span class="math inline">\(z\)</span> 为 <span class="math inline">\(b\)</span>。</li>
<li>如果 <span class="math inline">\(n\)</span> 是奇数，初始化 <span class="math inline">\(z\)</span> 为 <span class="math inline">\(x\)</span>。</li>
</ul></li>
</ul></li>
<li><strong>循环计算</strong>：
<ul>
<li>使用一个 <code>for</code> 循环，持续将 <span class="math inline">\(n\)</span> 除以 <span class="math inline">\(2\)</span>，直到 <span class="math inline">\(n\)</span> 为 0。</li>
<li>在每次循环中：
<ul>
<li>计算 <span class="math inline">\(x^2\)</span>（即 <span class="math inline">\(xx\)</span>），并检查是否溢出。</li>
<li>将 <span class="math inline">\(xx\)</span> 舍入到最近的基数 <span class="math inline">\(b\)</span>，并更新 <span class="math inline">\(x\)</span>。</li>
<li>如果 <span class="math inline">\(n\)</span> 是奇数，则计算 <span class="math inline">\(z\)</span> 的新值，并检查是否溢出。</li>
</ul></li>
</ul></li>
<li><strong>溢出检查</strong>：
<ul>
<li>使用 <code>revert</code> 来处理可能的溢出情况，确保计算的结果是有效的。</li>
</ul></li>
</ol>
</div>
<div id="总结" class="section level3 hasAnchor" number="7.23.3">
<h3><span class="header-section-number">7.23.3</span> 总结<a href="applications.html#总结" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>这段代码展示了如何利用汇编语言实现高效的二进制指数运算，同时关注溢出和舍入的问题。使用汇编可以获得更高的性能和更精细的控制，适用于对资源使用有严格要求的区块链应用场景。</p>
</div>
</div>
<div id="merkle-airdrop-空投" class="section level2 hasAnchor" number="7.24">
<h2><span class="header-section-number">7.24</span> 23 Merkle Airdrop 空投<a href="applications.html#merkle-airdrop-空投" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="merkle-airdrop" class="section level3 hasAnchor" number="7.24.1">
<h3><span class="header-section-number">7.24.1</span> Merkle Airdrop<a href="applications.html#merkle-airdrop" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>以下是使用 Merkle 树的空投合约示例。</p>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {MerkleProof} from &quot;./MerkleProof.sol&quot;;

interface IToken {
    function mint(address to, uint256 amount) external;
}

contract Airdrop {
    event Claim(address to, uint256 amount);

    IToken public immutable token;  // 代币合约的实例
    bytes32 public immutable root;  // Merkle 树的根
    mapping(bytes32 =&gt; bool) public claimed;  // 记录是否已领取的映射

    constructor(address _token, bytes32 _root) {
        token = IToken(_token);
        root = _root;
    }

    function getLeafHash(address to, uint256 amount)
        public
        pure
        returns (bytes32)
    {
        return keccak256(abi.encode(to, amount));
    }

    function claim(bytes32[] memory proof, address to, uint256 amount)
        external
    {
        // 注意: (to, amount) 不能有重复
        bytes32 leaf = getLeafHash(to, amount);

        require(!claimed[leaf], &quot;airdrop already claimed&quot;);
        require(MerkleProof.verify(proof, root, leaf), &quot;invalid merkle proof&quot;);
        claimed[leaf] = true;

        token.mint(to, amount);  // 领取代币

        emit Claim(to, amount);  // 触发领取事件
    }
}</code></pre>
</div>
<div id="代币合约" class="section level3 hasAnchor" number="7.24.2">
<h3><span class="header-section-number">7.24.2</span> 代币合约<a href="applications.html#代币合约" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

// ERC20 + mint + 授权功能
contract Token {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    uint256 public totalSupply;  // 总供应量
    mapping(address =&gt; uint256) public balanceOf;  // 每个地址的余额
    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;  // 授权额度
    string public name;  // 代币名称
    string public symbol;  // 代币符号
    uint8 public decimals;  // 小数位数
    mapping(address =&gt; bool) public authorized;  // 授权记录

    constructor(string memory _name, string memory _symbol, uint8 _decimals) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        authorized[msg.sender] = true;  // 部署者默认被授权
    }

    function setAuthorized(address addr, bool auth) external {
        require(authorized[msg.sender], &quot;not authorized&quot;);
        authorized[addr] = auth;  // 设置地址的授权状态
    }

    function transfer(address recipient, uint256 amount)
        external
        returns (bool)
    {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);  // 触发转账事件
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;  // 设置授权额度
        emit Approval(msg.sender, spender, amount);  // 触发授权事件
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount)
        external
        returns (bool)
    {
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);  // 触发转账事件
        return true;
    }

    function _mint(address to, uint256 amount) internal {
        balanceOf[to] += amount;
        totalSupply += amount;  // 更新总供应量
        emit Transfer(address(0), to, amount);  // 触发铸造事件
    }

    function mint(address to, uint256 amount) external {
        require(authorized[msg.sender], &quot;not authorized&quot;);
        _mint(to, amount);  // 铸造代币
    }
}</code></pre>
</div>
<div id="merkle-证明库" class="section level3 hasAnchor" number="7.24.3">
<h3><span class="header-section-number">7.24.3</span> Merkle 证明库<a href="applications.html#merkle-证明库" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<pre class="solidity"><code>// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts

pragma solidity ^0.8.20;

import {Hashes} from &quot;./Hashes.sol&quot;;

library MerkleProof {
    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)
        internal
        pure
        returns (bool)
    {
        return processProof(proof, leaf) == root;  // 验证 Merkle 证明
    }

    function processProof(bytes32[] memory proof, bytes32 leaf)
        internal
        pure
        returns (bytes32)
    {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i &lt; proof.length; i++) {
            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);  // 处理证明
        }
        return computedHash;
    }
}</code></pre>
</div>
<div id="测试合约" class="section level3 hasAnchor" number="7.24.4">
<h3><span class="header-section-number">7.24.4</span> 测试合约<a href="applications.html#测试合约" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;</p>
<p>library MerkleHelper {
// 冒泡排序
function sort(bytes32[] memory arr)
internal
pure
returns (bytes32[] memory)
{
uint256 n = arr.length;
for (uint256 i = 0; i &lt; n; i++) {
for (uint256 j = 0; j &lt; n - 1 - i; j++) {
if (arr[j] &gt; arr[j + 1]) {
(arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);
}
}
}</p>
<pre><code>    return arr;
}

function yulKeccak256(bytes32 a, bytes32 b)
    internal
    pure
    returns (bytes32 v)
{
    assembly {
        mstore(0x00, a)
        mstore(0x20, b)
        v := keccak256(0x00, 0x40)  // 计算哈希
    }
}

function calcRoot(bytes32[] memory hashes)
    internal
    pure
    returns (bytes32)
{
    uint256 n = hashes.length;

    while (n &gt; 1) {
        for (uint256 i = 0; i &lt; n; i += 2) {
            bytes32 left = hashes[i];
            bytes32 right = hashes[i + 1 &lt; n ? i + 1 : i];
            (left, right) = left &lt;= right ? (left, right) : (right, left);
            hashes[i &gt;&gt; 1] = yulKeccak256(left, right);  // 计算根哈希
        }
        n = (n + (n &amp; 1)) &gt;&gt; 1;  // 更新 n 的值
    }

    return hashes[0];  // 返回根
}

function getProof(bytes32[] memory hashes, uint256 index)
    internal
    pure
    returns (bytes32[] memory)
{
    bytes32[] memory proof = new bytes32[](0);
    uint256 len = 0;

    uint256 n = hashes.length;
    uint256 k = index;

    while (n &gt; 1) {
        // 获取当前层的证明
        uint256 j = k &amp; 1 == 1 ? k - 1 : (k + 1 &lt; n ? k + 1 : k);
        bytes32 h = hashes[j];

        // proof.push(h)
        assembly {
            len := add(len, 1)
            let pos := add(proof, shl(5, len))
            mstore(pos, h)
            mstore(proof, len)
            mstore(0x40, add(pos, 0x20))
        }

        k &gt;&gt;= 1;

        // 计算下一层的哈希
        for (uint256 i = 0; i &lt; n; i += 2) {
            bytes32 left = hashes[i];
            bytes32 right = hashes[i + 1 &lt; n ? i + 1 : i];
            (left, right) = left &lt;= right ? (left, right) : (right, left);
            hashes[i &gt;&gt; 1] = yulKeccak256(left, right);
        }
        n = (n + (n &amp; 1)) &gt;&gt; 1;
    }

    return proof;  // 返回证明
}

function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)
    internal
    pure
    returns (bool)
{
    bytes32 h = leaf;

    for (uint256 i = 0; i &lt; proof.length; i++) {
        (bytes32 left, bytes32 right) =
            h &lt;= proof[i] ? (h, proof[i]) : (proof[i], h);
        h = yulKeccak256(left, right);  // 验证证明
    }

    return h == root;  // 检查是否匹配
}</code></pre>
<p>}</p>
<p>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;</p>
<p>import {Test, console2} from “forge-std/Test.sol”;
import {MerkleHelper} from “./MerkleHelper.sol”;
import {Airdrop} from “../../../src/app/airdrop/Airdrop.sol”;
import {Token} from “../../../src/app/airdrop/Token.sol”;</p>
<p>contract AirdropTest is Test {
Token private token;</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="solidity-example.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="hacks-evm-test-and-defi.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/USERNAME/REPO/edit/BRANCH/06-share.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf", "_main.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
